<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- fonts -->
    <link href='http://fonts.googleapis.com/css?family=Signika+Negative:300,600' rel='stylesheet' type='text/css' />
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:700' rel='stylesheet' type='text/css' />
    <link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">

    <script data-js="root" src="../js/jquery.js"></script>
    <script data-js="root" src="../js/consent.js"></script>

    <!-- blog stuff -->
    <link rel="alternate" type="application/rss+xml" title="Subscribe to this page..." href="http://feeds.feedburner.com/WaitingForTheJobsToFinish" />
	<link rel="stylesheet" href="main.css" type="text/css" />
	<link rel="stylesheet" href="blog.css" type="text/css" />
    <!-- /blog stuff -->
<title>Carlos Fenollosa &#x2014; Blog &mdash; Posts tagged "software"</title>
<meta name='twitter:card' content='summary' />
<meta name='twitter:site' content='@cfenollosa' />
<meta name='twitter:title' content='Carlos Fenollosa &#x2014; Blog &mdash; Posts tagged "software"' />
<meta name='twitter:description' content=" A simple script to postpone your own email   January 14, 2016 &mdash;  Carlos Fenollosa    I somewhat use email as a task manager. Honestly, I believe we all do. We process emails in the inbox, then archive or delete them when we are done with them." />
</head><body>

<div id="cookieBanner">
    <div id="cookieBannerClose"><a href="javascript:;">x</a></div>
    This website uses third party cookies exclusively to collect analytics data.
    If you continue browsing or close this notice, you will accept their use.
    The EU now requires all sites to display this banner which confuses users
    and does nothing, actually, to improve your privacy.<br/>
    <div id="cookieBannerActions">
        <a class="noconsent" href="http://cfenollosa.com/blog/the-ignorant-eu-cookie-law.html">Read more on why this law is ignorant</a> &mdash; 
        <a class="noconsent" href="http://cfenollosa.com/cookies.html">Learn about this website's cookies</a> &mdash; 
        <a class="denyConsent noconsent" href="javascript:;">Disallow cookies</a>
    </div>
</div>


<div class="headerbig"><div class="head">
	<div class="headerleft">
		<img data-img="root" src="../img/cfenollosa-small.png" alt="Carlos Fenollosa" class="foto" />
	</div>

	<div class="headerright">
        <div id="headername">
            <h1 class="nomargin name">Carlos Fenollosa</h1>

            <div class="description">
                <div class="position">Engineer, developer, entrepreneur</div>
            </div>
        </div>

        <div class="add" id="contact">
            <a href="mailto:cf@cfenollosa.com">cf@cfenollosa.com</a> <i class="fa fa-envelope fa-fw"></i><br/>
            <a href="http://twitter.com/cfenollosa">@cfenollosa</a> <i class="fa fa-twitter fa-fw"></i><br/>
            Barcelona area <i class="fa fa-map-marker fa-fw"></i>
        </div>

        <div class="clear"></div>			
	</div> <!-- headerright -->
<div class="clear"></div>
</div></div> <!-- header && headerholder -->


<div id="navbar" class="bound">
    <div data-id="idblog" class="navitem navitem-first navitem-current"><a href="index.html">Blog</a></div>
    <div data-id="idabout" class="navitem"><a href="../about.html">About</a></div>
    <div data-id="idfunnypapers" class="navitem"><a href="../funnypapers/index.html">Funny papers</a></div>
    <div data-id="idpuput" class="navitem"><a href="http://puput.io">Puput</a></div>
    <div class="navitem"><a href="http://github.com/cfenollosa">Github</a></div>
    <div data-id="idlinkedin" class="navitem navitem-last"><a href="https://www.linkedin.com/in/cfenollosa">LinkedIn</a></div>
    <div class="clear"></div>
</div>
<div id="divbodyholder">
<div class="headerholder"><div class="header">
<div id="title">
<h1 class="nomargin"><a class="ablack" href="http://cfenollosa.com/blog/index.html">Carlos Fenollosa &#x2014; Blog</a></h1>
<div id="description">Thoughts on science and tips for researchers who use computers</div>
</div></div></div>
<div id="divbody"><div class="content">
<h3><a class="ablack" href="a-simple-script-to-postpone-your-own-email.html">
A simple script to postpone your own email
</a></h3>
<!-- bashblog_timestamp: #201601141736.00# -->
<div class="subtitle">January 14, 2016 &mdash; 
Carlos Fenollosa
</div>
<!-- text begin -->

<p>I somewhat use email as a task manager. Honestly, I believe we all do. We process emails in the inbox, then archive or delete them when we are done with them.</p>

<p>However, keeping track of emails that need a follow-up on a specific date can be difficult.</p>

<p>Around 2011 I wrote a script to perform that task. It is a very simple IMAP parser that searches for a folder with today's date and moves all its contents to a special folder named "Today".</p>

<p>Let me tell you my email workflow. I understand that not everybody works in the same way, but maybe you can get some ideas to improve your email handling.</p>

<p>My email folder structure looks like this. The interesting part is in bold.</p>

<pre>
Inbox
\_ Mailing lists
\_ Project folders
\_ ...
<strong>
\_ Deadlines
     \_ Today
     \_ Tomorrow
     \_ 2016-01-19
     \_ 2016-02-02
     ...
     \_ 2017-08-01
</strong>
</pre>

<p>I follow the GTD methodology, which essentially states that tasks should either be done on the spot, delegated, or deferred. Thus, my inbox is exclusively for new tasks. A couple of times a day I process incoming email and, like most of us, either delete it, reply to it, forward it or &mdash;this is the interesting part&mdash; move it to one of the "Deadlines" folders.</p>

<p>Instead of using the inbox as the "email task manager", I use a folder named "Today". I've tried both alternatives, and I find that it works best for me. Since it separates new tasks from tasks I've already processed, I can work my entire day on "Today" and totally forget about the Inbox, even if new email is arriving.</p>

<p>The "Tomorrow" folder is just a shortcut so that I don't need to create a new folder with tomorrow's date every day.</p>

<p>As you may have guessed, the script runs once a day in a crontab, at 6 AM, and moves all mail from "Tomorrow" and the folder with tomorrow's date to "Today". That's it. And that "simple trick", as fishy marketers like to say, saves me a lot of time and headaches every day.</p>

<p>There is currently a commercial alternative, <a href="http://www.boomeranggmail.com">Boomerang</a>, which you may find interesting if you aren't comfortable with programming. I haven't used it, so I can't comment on that. In any case, I usually prefer writing a small script rather than using a third-party service.</p>

<p>Update: <a href="https://github.com/kapravel/snoozegmail">this script</a> by Alex Kapravelos does something very similar, 
and it integrates with Google Apps Scripts.</p>

<p><a href="https://gist.github.com/cfenollosa/79c22e2ecbb2bdfee15b">Here it is, as a Gist</a>. 
The code is definitely not the best in the world, but it works. Feel free to use it, modify it (BSD license), give feedback and leave comments.</p>

<p>I hope that you can introduce some ideas from this methodology to your daily workflow. it can be as useful as it's been for me.</p>

<script src="https://gist.github.com/cfenollosa/79c22e2ecbb2bdfee15b.js"></script>

<p>Tags: <a href='tag_software.html'>software</a>, <a href='tag_tricks.html'>tricks</a>, <a href='tag_productivity.html'>productivity</a></p>





<!-- text end -->
<p id='twitter'><a href='http://twitter.com/intent/tweet?url=http://cfenollosa.com/blog/a-simple-script-to-postpone-your-own-email.html&text=&lt;Type your comment here but please leave the URL so that other people can follow the comments&gt;&via=cfenollosa'>Comments? Tweet</a> 
<a href='https://twitter.com/search?q=http://cfenollosa.com/blog/a-simple-script-to-postpone-your-own-email.html'><span id='count-15855'></span></a>&nbsp;</p>
<script type="text/javascript">$.ajax({type: "GET", url: "https://cdn.api.twitter.com/1/urls/count.json?url=http://cfenollosa.com/blog/a-simple-script-to-postpone-your-own-email.html",
            dataType: "jsonp", success: function(data){ $("#count-15855").html("(" + data.count + ")"); }}); </script>
<h3><a class="ablack" href="puput-mail-without-internet.html">
Puput, mail without internet
</a></h3>
<!-- bashblog_timestamp: #201512211725.00# -->
<div class="subtitle">December 21, 2015 &mdash; 
Carlos Fenollosa
</div>
<!-- text begin -->

<p>Here's my new project: <a href="http://puput.io">Puput</a>, a service which lets you
listen to your email when you have no internet.</p>

<p>I honestly think it's pretty cool, the project has a strong R+D component for which we filed a patent,
and it has lots of potential to <a href="http://puput.io/slack.html">integrate into IMs like Slack</a>
and close the communication gap for people who are offline.</p>

<p>It's free, so please be my guest and give it a try! It's surprisingly awesome to be able to listen
to your email when you're abroad without an internet connection.</p>

<p>Even though we have been absorbing a lot of startups-related material these last months,
nothing will prepare you for a real product launch. Everybody says it, and I agree: </p>

<ul>
<li>The last 20% of the work consumes us 80% of the time. That is, UI, UX, the website,
and the marketing strategy</li>
<li>Selling is hard.</li>
<li>Selling is even harder when you first invent a new technology and then try to find 
use cases for it. Yes, the <em>lean startup</em> recommends doing the opposite, it is a common
first timer mistake :(</li>
<li>I'll say it again, do product/market fit first, then start coding.</li>
<li>Raising money is nearly impossible in the Spanish startup scene. Obviously we're nobodies, but
I've also talked to many other founders, with great products, thousands of clients and 
two-digit monthly growth, who find it incredibly frustrating to raise even 200k&euro;</li>
<li>Launch day is scary so you find excuses not to launch. Adding more features is one of them. Establish
hard deadlines and try to respect them as much as possible.</li>
<li>It turns out it isn't that scary anyways, in fact, getting users and attention is difficult at first.
<em>Dying from success</em> is unrealistically represented in sites like HN, it doesn't apply to 99% of the startups.</li>
</ul>

<p>Anyway, launching a product is hard, teaches you many things about the world, and makes you
respect people who have done it successfully. </p>

<p>Cheers to all first time founders.</p>

<p>Tags: <a href='tag_internet.html'>internet</a>, <a href='tag_software.html'>software</a>, <a href='tag_startups.html'>startups</a>, <a href='tag_projects.html'>projects</a></p>





<!-- text end -->
<p id='twitter'><a href='http://twitter.com/intent/tweet?url=http://cfenollosa.com/blog/puput-mail-without-internet.html&text=&lt;Type your comment here but please leave the URL so that other people can follow the comments&gt;&via=cfenollosa'>Comments? Tweet</a> 
<a href='https://twitter.com/search?q=http://cfenollosa.com/blog/puput-mail-without-internet.html'><span id='count-30786'></span></a>&nbsp;</p>
<script type="text/javascript">$.ajax({type: "GET", url: "https://cdn.api.twitter.com/1/urls/count.json?url=http://cfenollosa.com/blog/puput-mail-without-internet.html",
            dataType: "jsonp", success: function(data){ $("#count-30786").html("(" + data.count + ")"); }}); </script>
<h3><a class="ablack" href="openbsd-from-a-veteran-linux-user-perspective.html">
OpenBSD from a veteran Linux user perspective
</a></h3>
<!-- bashblog_timestamp: #201506261919.00# -->
<div class="subtitle">June 26, 2015 &mdash; 
Carlos Fenollosa
</div>
<!-- text begin -->

<p>For the first time I installed a BSD box on a machine I control. The experience has been eye-opening, especially
since I consider myself an "old-school" Linux admin, and I've felt out of place with the latest changes on the
system administration. </p>

<p>Linux is now easier to use than ever, 
but administration has become more difficult. There are many components, most of which
are interconnected in modern ways. I'm not against progress, but I needed a bit of recycling. So instead of
adapting myself to the new tools, I thought, why not look for modern tools which behave like old ones?</p>

<p>This article discusses some of the main differences between OpenBSD and Linux, from a Linux admin perspective.</p>

<p>There are some texts on the net discussing the philosophical differences between BSDs and Linux, but
not many of them are really hands-on. <a href="https://www.over-yonder.net/~fullermd/rants/bsd4linux/01">This one</a> is the best,
and I recommend you to read it along with this one.</p>

<p>Since I am new to OpenBSD, I may get some things wrong. Please email me any corrections.
However, my goal is to point out my first impressions, so if there are any Linux users reading and thinking about making the jump, 
they can know what to expect.</p>

<p><em>Final update: I've received a huge amount of feedback from this article, overwhelmingly
positive, and very welcoming from the OpenBSD community.</em></p>

<p><em>This text's goal is to discuss an OpenBSD newbie's first impressions and, as such, I'm
realizing that some parts aren't totally accurate. However, I want to keep that perspective,
so in the future I'll prepare a more technical guide on how to migrate to OpenBSD for Linux users.
Thanks everyone!</em></p>

<h4>The "RAMDAC" running joke</h4>

<p>First, some background about my Linux experience.</p>

<p>My first computer was a 386 with DOS and Windows 3.1. I had played with Spectrums, Commodores, and
IBM PCs (8086). I followed the traditional Windows path: 3.1 -> 95 -> 98 -> ME -> 98 -> 2000. But
I always liked computers, and the most visible part of them, besides the hardware, is the OS.</p>

<p>I tried to install my first Linux distro on 1999. It was a Red Hat Linux 5.2, if I remember correctly, 
and I got the CD from a magazine because I was still running a dial-up. I was 15 and I thought I knew
computers, after all, I had assembled my own, an AMD K6-2 box, from parts.</p>

<p>Red Hat proved me wrong.</p>

<ul>
<li><em>Which is your chipset?</em></li>
<li>Man, I don't know</li>
<li><em>Which is the model of your RAMDAC?</em></li>
<li>What is a RAMDAC?</li>
<li><em>I need <a href="http://archive.download.redhat.com/pub/redhat/linux/7.1/kr/doc/RH-DOCS/rhl-ig-itanium-en-7.1/figs/textmode/monitor.gif">your monitor modelines</a>. Don't get them wrong or you will physically damage your CRT</em></li>
<li>Dude, I'm 15, I can't afford to break anything!</li>
</ul>

<p>In the end I didn't break my monitor, but
got a black screen which said <code>login:</code>, and didn't know what to do, so I booted back
into Windows and played a bit of Warcraft 2.</p>

<p>In that age we only had one computer, so if you were installing something and needed
help, you had to stop, reboot into Windows, dial up the modem, search the Usenet or forums, write down
the solution on a piece of paper&mdash;no ubiquitous printers&mdash;, hope you got the commands right, reboot, start the installation over,
reach the point where you previously were, and apply that solution. Not practical at all. </p>

<p>The best
help we had were books, and those were expensive and difficult to find on a small town bookstore.
For those of us not fortunate enough to buy/find books, we had hobbyist magazines. In Spain there were a few
imported and poorly translated magazines which were expensive, but carried some CDs, the only practical
way to get distros.</p>

<p>The first Linux I really was able to use was Mandrake 6.0. It had a graphical installer&mdash;not that having graphics
made any real difference on the final result&mdash; but it auto detected my hardware correctly and booted into X. Yeah! 
<a href="http://www.betaarchive.com/imageupload/2014-12/1419415455.or.26035.png">Old Linux software</a>! 
A game called Nethack which had nothing to do with hacking! <code>sysconfig</code>!</p>

<p>Unfortunately, I couldn't connect to the internet because of my Winmodem, so after a few days of tinkering, Mandrake 
was wiped too.</p>

<p>Months later, I got myself a BeOS CD. It was like Linux, which for me, then, meant it was not Windows. The setup ran totally
effortless and it even detected my Winmodem. The internet ran faster than on Windows. It had a great
internet browser, mail and newsgroups clients. Oh, boy! I used BeOS for a long time almost exclusively
and only booted Windows to play some games.</p>

<p>A couple years later I started Computer Engineering on college, so I wiped out everything and installed Linux.
I got a new machine and a real network connection.</p>

<p>I've run lots of Debians, Red Hats, Mandrakes, Gentoos and Slackwares. We used Solaris and even some VAXes.
I ran some servers for student organizations, and finally settled on Debian as "the best" distro: stable,
easy to use, no need to compile on our 486, nice hardware detection and with a big community.</p>

<p>Finally, I moved to Ubuntu if only because its LTS releases. Around 2006 I got into Macs, which at first seemed like a nicer Linux, and
now I appreciate the hardware+software combo for which I know I won't have to fight with its drivers. </p>

<p>In summary, I've seen a lot of UNIX, even more Linux, and administered a good chunk of them. My servers have
always run some sort of Debian.</p>

<p>You could say that as I grew older I also grew tired of fighting with RAMDACs, modelines and Winmodems.
Each age brought new "RAMDACs": CD recording, wireless card support, laptop hibernation, webcams, divx playing,
DVD playing, NTFS support...</p>

<p>Linux always worked in the server but had some quirks in the desktop which made it somewhat unattractive for daily use,
even when I run it exclusively on my laptop.</p>

<p>Nowadays, Macs offer a UNIX with some peace of mind, and the current status of Linux is good enough. Some of the friends I
evangelized long ago&mdash;I quit doing that&mdash;still use Ubuntu and are happy with it. Linux may never triumph
on the desktop (or laptop), but it's good enough for most.</p>

<h4>Upgrading a G4 Mac Mini</h4>

<p>Now jump to 2015. My home server, a G4 Mac Mini, was already two Debians behind. Some packages weren't ported to
<em>powerpc</em>. I needed to perform a clean install and upgrade the whole system either way. But this time I didn't want to use a Linux
installation which wants me to reboot every 5 days because of some critical patch. I'm looking at you, Ubuntu.</p>

<p>As you can imagine my operating system fascination didn't fade out, only my time. I had been closely following the BSDs and
using <a href="http://cfenollosa.com/blog/the-sdf-public-access-unix-system----est-1987.html">a NetBSD shell account</a>, installed Plan 9
on a virtual machine,
and even wrote <a href="https://github.com/cfenollosa/os-tutorial">a toy OS project</a>. </p>

<p>I'm not afraid of compiling stuff&mdash;I do it for a living&mdash; and may even be open 
to modifying some code if needed. Why not try something new?</p>

<p>Since I had the weird <em>powerpc</em> requirement, I ruled out most operating systems. Finally I decided to play relatively
safe and go for a BSD. FreeBSD is the most popular, has
more online HOWTOs, and probably more features (ZFS, Jails), though I probably would not be using them. OpenBSD
is more hackable, seems to have better documentation, and some cool people I know use it. I didn't want to quit using a pot
to start using a kettle, so I downloaded OpenBSD's <code>install57.iso</code></p>

<p>It was impossible to boot the Mini with a USB stick; I'm unsure if it's the firmware's fault
or the fact that I was <code>dd</code>'ing the .iso file into the USB instead of the .fs one which doesn't seem to be available
for macppc.</p>

<p>I found some blank DVDs on a closet, borrowed a computer 
with a DVD drive&mdash;another medium I hadn't touched in years&mdash;, and burned the ISO image. 
The fact that I recorded the first disk with the ISO file on the root folder
instead of properly burning the contents into the DVD warned me that this was going to be hard, but fun... </p>

<p>Surprisingly, the installation was straightforward, it detected the 10-yr-old hardware, and by following the instructions
I managed to partition the disks and install the boot loader. The box was up and running.</p>

<p>Well, that wasn't so hard, was it? Now, to restore my old installation.</p>

<p>Hm, first of all, 
<code>bash</code> needs to be installed from packages and goes into <code>/usr/local/bin</code>, so I had to
modify a lot of scripts which pointed to <code>#!/usr/bin/env bash</code>. The <code>ps</code> and <code>tar</code> commands have slightly different
switches which broke other scripts. 
The base services are different; OpenBSD includes its own HTTP, SMTP and NTP servers. Configuration files
are in different places. Here goes my week...</p>

<h4>GNU is really not UNIX</h4>

<p>A quick note on the GNU/Linux naming discussion, since GNU is entering the equation now.
I use the term "Linux" for simplicity. I know that's the kernel name. It also happens to be
the popular name, even if not totally correct&mdash;according to some.</p>

<p>Here is some food for thought; why does the FSF deserve more credit on the name than, say, the Apache Foundation, 
or the FreeDesktop project, or BSD, for that matter? Why don't we include every key component on the name 
and call it GNU/FreeDesktop/Apache/OSI/BSD/.../Linux? Including only GNU would be unfair
to other big contributors, wouldn't it? So let's please stop this fight.</p>

<p>That being said, the GNU tools and design philosophy make a noticeable difference in administration and userspace, and one can only appreciate
it when switching to a different environment.</p>

<p>I don't want to overstate it, though. Thanks to POSIX, a Linux admin
can run BSD with little extra effort, since most of the things are similar. There are, in fact, more similarities than
differences. If FreeBSD and OpenBSD are brothers, then Linux is a close cousin.</p>

<p><code>ls</code> is always <code>ls</code>. <code>mkdir</code> is <code>mkdir</code>.
But when you're being used to <code>/dev/hda</code>, <code>free -m</code> and <code>cat /proc/cpuinfo</code> you realize that having a different
kernel is naturally going to change some of the administration tools.</p>

<p>Some say that the GNU tools <a href="http://suckless.org/sucks">are bloated</a> and that the BSD toolchain is more "pure UNIX".
The reality is that it depends on the specific GNU tool, I've personally found that GNU tools are more complex because
they're more powerful, though they are less UNIX-like <em>(do one thing only and do it well)</em> and more like complete
solutions. That's fine; different, but fine. After all, GNU is not Unix!</p>

<p>In recent years, the Linux environment has grown in the GNU toolchain fashion, not the UNIX fashion. One may even say
it has grown in the <em>Windows fashion</em>: be practical, be accommodating to all, be fast, be modern.</p>

<p>There have always been debates
about "bloated and complex code". More recently, systemd. Previously, Apache, sysconfig, iptables/iptools.... 
The list goes on and on. Wheel out comp.os.linux and look at the flame wars.</p>

<p>No software fits all nor should be shamed for its design decisions. In the end, with
a few critical exceptions like <a href="https://en.wikipedia.org/wiki/Heartbleed">OpenSSL and the Heartbleed bug</a>, it is just
a matter of taste: does the admin prefer simple, pluggable services, or bit monolithic suites? Compatibility or modernness?
Familiarity or <a href="http://www.jwz.org/doc/cadt.html">shiny new things</a>? Standards or <a href="https://en.wikipedia.org/wiki/Not_invented_here">NIH</a>?</p>

<p>I had been riding the Linux wave for years, until I recently realized that my admin skills needed a total
recycling. In a few years we've gone from <code>/etc/init.d/sshd restart</code> to <code>service sshd restart</code> to <code>systemctl start sshd</code>.
That's a bit fast in my opinion, but I understand it's the price of progress, aimed to make computers boot
faster and theoretically easier to administer for newcomers. Old admins, on the other hand, have a harder time adapting.</p>

<p>Having to choose between recycling into an always changing Linux or a more stable UNIX environment, I chose OpenBSD.
Given my history of trying all possible OSs, 
Let me state again that I'm not against the recent Linux direction. I just wanted to go out and see if there is a different way
to do things.</p>

<h4>Differences between OpenBSD and Linux</h4>

<p>Maybe you're reading this article for its practical value and not for my ramblings, sorry.
I thought I had to provide some context. I'm used to googling, I'm used to RTFMing, I'm used
to reading source code to learn what software does. This context is important to judge if
you would notice the same differences as I did.</p>

<p>Here's a list of things that surprised me the most after completing an OpenBSD install, adapting
my old setup to the new environment and running it for a few days.</p>

<p><strong>Simplicity</strong></p>

<p>First of all, everything is much simpler, like the Linux old days. Not necessarily easier, but
simpler. More minimalistic. I found this plays well with my mind. OpenBSD follows <a href="http://www.catb.org/esr/writings/taoup/html/ch01s06.html">the UNIX 
philosophy</a> 
more closely: lots of small components that do one thing and 
talk between them by passing text.</p>

<p>Because of that, some base components are not as feature-rich, on purpose. Since 99% of the servers don't need
the flexibility of Apache, OpenBSD's httpd will work fine, be more secure, and probably faster.
For those who need the big boys, just install Apache from the packages. </p>

<p>Having a developer-chosen default option for many servers is a time saver. The admin knows it will be
well supported and documented, and tightly integrated with other components. The alternative, the
Linux way, is to just use what everybody else uses (Apache), or choose one of the multiple options, always
wondering if it's the right one&mdash;nginx? lighttpd? thttpd? You know what... <em>nobody got ever fired
for choosing Apache</em></p>

<p><strong>Design decisions</strong></p>

<p>Picking up on that thought,
the system is very opinionated. When the community decides that some module sucks, they develop
a new one from scratch. OpenBSD has its own NTPd, SMTPd and, more recently, HTTPd. They work
great.</p>

<p>Likewise, the standard shell is <code>pdksh</code>. The <a href="http://www.openbsd.org/faq/faq9.html">OpenBSD FAQ</a> states that 
<em>"Users familiar with bash are encouraged to try ksh(1) before loading bash on their system -- it does what most people desire of bash."</em>,
which is a bit too bold. ksh does not support history substitution (<code>sudo !!:1</code>) which I use a lot, though I agree
that for many users it will be enough. Many people hate bash for a reason, I am not one of them.
Having a super powerful shell has saved me from writing perl scripts for system administration.
Bash can always be installed from packages, anyway.</p>

<p>This is a big difference from Linux, which is more like a "consensus" operating system. Developers have
to keep compatibility and whenever there is a controversial design decision like systemd, dozens of
projects <a href="https://xkcd.com/927/">decide to fork</a>. Not good.</p>

<p>Strong opinions, on the other hand also lead to less support for some, like ext4, ZFS or Linux binary compatibility.
For example, ext4 is officially supported read-only but in my case it didn't read some folders properly.
FreeBSD plays better on that regard, though they also have more developer manpower. This leads to some use cases, 
like an OpenBSD desktop, being possible but not the best choice for this OS.</p>

<p>Finally, other decisions make little sense. According to disklabel(8), the /usr partition takes
about 2G of disk space, not including /usr/src or /usr/obj. This means that there is little
space to hold what is essentially the whole system plus ports. I had trouble compiling large ports
since /usr ran out of disk space. If a large number of users will be compiling some ports, why not
set a larger /usr by default?</p>

<p><strong>Documentation</strong></p>

<p>The man pages are excellent, a delight. Unlike Linux, they
are not just a list of switches for the software, but a comprehensive guide to the tool, with
lots of examples. They are much, much better&mdash;thankfully, because unlike Linux, again,
there are not tons of help on public forums.</p>

<p>OpenBSD's man pages are so nice that RTFMing somebody on the internet is not condescending but selfless.</p>

<p>Granted, I wouldn't make a UNIX novice run OpenBSD from man pages, but for an experienced admin, they contain
exactly the information they need.</p>

<p><strong>Small differences in common tools</strong></p>

<p>Using the BSD toolchain instead the GNU one means there are small differences between tools. 
For example, some <code>ps</code> switches are missing, like the useful <code>-f</code>. The <code>tar</code> options for reading from stdin
are also slightly different. When <code>ls</code> is run by root, it automatically appends all hidden files.</p>

<p><code>df</code> has <code>-h</code> (human) and <code>-k</code> (kilobytes), but no <code>-m</code> for megabytes.</p>

<p>If you've used MacOS you probably know a few of these.</p>

<p><strong>Packages</strong></p>

<p>OpenBSD has packages, like Linux. Unlike it, packages are only available for 3rd party software, not the base
system. </p>

<p>OpenBSD's base system is more or less what gets installed from the CDs: kernel, shell, coreutils,
a small part of X and essential servers (http, ntp, smtp, etc.) Everything else must be installed from packages.</p>

<p>The documentation recommends using packages, since it is not worth it to compile from ports&mdash;the package
sources. However, packages don't get security updates. The only way to patch bugs is to compile the ports.</p>

<p>Fortunately, there is a simple way to use the best of both worlds: add <code>FETCH_PACKAGES=yes</code> to <code>/etc/mk.conf</code>
and install software from ports. The system will automatically fetch the package and save the compilation 
time if there is a current binary available.</p>

<p>Another interesting tool is <code>/usr/ports/infrastructure/bin/out-of-date</code>, which checks which ports need
an update, so you can go to <code>/usr/ports/&lt;portname&gt;</code> and <code>make update</code>. This command plays well with previously
installed packages, so you don't have to worry deleting them first.</p>

<p>In summary, after you install the release, if you're interested in getting security updates until next
release, the officially recommended path is to <a href="http://www.openbsd.org/stable.html">follow -stable</a>, use <code>FETCH_PACKAGES</code> and work from ports.
This is not very clear in the documentation but the folks at <a href="irc://freenode.net/openbsd">#openbsd</a>
helped me figure it out.</p>

<p>As a colophon, if you're using x86 or amd64, <a href="https://stable.mtier.org">m:tier</a> provides binary updates
for the base system and packages, much like Linux does. Otherwise, if 
there is any bug in the base system you'll need to
recompile that part yourself. The amount of compiling needed will be determined
by the patched component and any related software, so just read the
instructions on the patch.</p>

<p><strong>Configuration files</strong></p>

<p>The base system config files are properly centralized in <code>/etc</code>, but
not the ports. The porting quality is excellent, better than any Linux distro. Every port is adapted
to the OpenBSD system and made sure it behaves correctly. However, some maintainers decide that all
the port files need to be contained in some folder, like <em>transmission-daemon</em>, which stores its
config into <code>/var/transmission/.config/transmission-daemon/settings.json</code>. It's a bit crazy to store
a system-wide daemon config file into <code>/var</code> which, according to <code>man hier</code>, contains
<em>Multi-purpose log, temporary, transient, and spool files</em>. </p>

<p>Apparently some daemons are chrooted by default, and there is a global "catch-all" README folder
on <code>/usr/local/share/doc/pkg-readmes</code> which contains specific info about packages. transmission-daemon
had no related info, so maybe I'll contact the maintainer.</p>

<p><strong>Chroot</strong></p>

<p>Speaking of roots, nearly all daemons in the base system are chrooted and
privstep by default. The base system has a lot of hardening by default,
which is one of the main reasons why OpenBSD has almost no remote holes
on the default installation.</p>

<p>Since chrooting software in Linux can be cumbersome, it's very convenient
to get it done for you, so thanks!</p>

<p><strong>Experienced community</strong></p>

<p>I feel like the learning curve
is a feature, not a bug, intended to keep newcomers away. OpenBSD is unapologetically elitist.
Honestly, I don't mind that. I've been administering systems for more than a decade
and not all environments are for everybody.</p>

<p>OpenBSD <em>can afford</em> to be elitist because it is a small system, with a clear direction, the documentation
is crystal clear, and it doesn't make vague promises.</p>

<h4>make build</h4>

<p>As you can see there is a big <em>con</em> to using OpenBSD coming from a Linux world, 
the process for patching security issues. On Linux I was used to
run a single command and let any part of the system (base or 3rd party) update itself. With
OpenBSD, it takes a lot more effort and time, especially in my old machine.</p>

<p>This process leaves the admin only one realistic option: follow the -stable branch, which is basically the same
code as the CD release with small patches, and recompile stuff regularly. Otherwise, the installed
system will be exposed to potential security holes until the next release.</p>

<p>I feel that this needs to be more prominent in the OpenBSD docs, especially on the <a href="http://www.openbsd.org/faq/faq9.html">Migrating to OpenBSD</a>
section: <em>if you want an updated and stable
system you'll need to recompile stuff constantly, there is no equivalent to <code>apt-get upgrade</code></em>.</p>

<p>To get a secure production system with OpenBSD, the officially recommended path is to:</p>

<ol>
<li>Install the CD release</li>
<li>Download the source code</li>
<li>Recompile the kernel (recommended by "following -stable")</li>
<li>Recompile userland</li>
<li>Download ports tree</li>
<li>Add <code>FETCH_PACKAGES=yes</code> to <code>/etc/mk.conf</code> to let ports fetch packages, if available,
and install software using the ports syntax.</li>
<li>Recompile when there is a security issue which affects
your setup, though you may skip some compiling if using m:tier.</li>
</ol>

<p>Of course, this is a feature, not a bug, but it's the biggest admin change from old Linux users.
That's a lot of effort compared to <code>apt-get update &amp;&amp; apt-get upgrade</code>. Honestly, had I known it,
I would've more strongly considered keeping my Debian installation. I read all the online documentation before
installing OpenBSD, and I felt like this point wasn't really clear.</p>

<p>Since you can safaly use -stable ports/packages with a -release base system, 
steps 3-4 can be avoided or shortened if you don't want to update your base to -stable. That's
what I would recommend to former Linux users, but take this newbie's advice with a grain of salt.</p>

<p>In any case, for low-performing machines like mine, maybe the "recommended" path to follow -stable
and rebuild the source for every errata is not the best one. For small fixes it may be better
to just apply the patch and follow its instructions. Apparently in faster machines it's just
more convenient to recompile the base system since it takes just a few minutes. 
Had I been using x86 or amd64, I'd have totally gone for m:tier, so you can dismiss this section.</p>

<p>To be totally fair, it's rare for OpenBSD to have remote holes on the CD release, so one could
be relatively safe by only upgrading from release to release. But the truth is that there is
no simple way to binary patch for critical updates.</p>

<p>With that it mind, to summarize, there are the following options:</p>

<ul>
<li>Use a -release base and -stable ports (with <code>FETCH_PACKAGES=YES</code>), 
cherry-picking patches from base and updating ports by <code>make update</code>.
This may be the recommended path for low-performing machines</li>
<li>Use a -stable base, too. You can then update the whole system with a 
handful of commands and won't need to follow patch instructions</li>
<li>Use -release and update from m:tier</li>
<li>Keep using -release until a next -release comes, unless there is
an unlikely remote hole that forces you to recompile the base. This
may be the best option for newbies if the only person using the box 
is the admin, so there is no way to suffer local attacks.</li>
</ul>

<h4>Conclusion</h4>

<p>From a user perspective all of this is transparent; OpenBSD has a UNIX terminal or Xwindows session
and everything works as expected. But a Linux admin will need to adapt to these new tools and
allocate some more time for administration.</p>

<p>OpenBSD has pros and cons. Personally, my main pros are the excellent documentation, its minimalism and
the choice of default daemons. The only con is the need to recompile to patch errata.
If I had just one wish for OpenBSD, it would be a more straightforward updating system for 
security errata.</p>

<p>Now, the dreaded question. <em>Is it worth it?</em></p>

<p>Honestly, I wasted too much time. Some of it was to be expected, since I needed to learn a different
environment. Had I been 10 years younger, this wouldn't have been a problem, but
I want a hassle-free environment. The fact that I needed to compile things on an old machine
probably didn't help. Keep that in mind when considering a BSD for an old, weird architecture.</p>

<p>After the initial investment, I want to see if maintenance is easier and release upgrades
are smoother than with Debian. Manually upgrading things is a pain in the neck, but all other
factors lead me to think that OpenBSD is a great server OS.</p>

<p>Maybe I was expecting something else from the docs I read? It 
is probably my fault, though. Anyway, I want to contribute to the available documentation by
writing this document so that other Linux admins can make a more informed decision.</p>

<p>On the other hand, my geeky side is content. OpenBSD rocks. It is a different&mdash;a real&mdash;UNIX
and I've really come to appreciate simple code and software. As an admin, having minimalistic, default
servers is a blessing.</p>

<p>Again, should you try OpenBSD? The answer is yes, though be careful if you're either in a rush or have 
specific software requirements. The first days are a bit hard,
and recompiling on a slow machine takes time.</p>

<p>If you like UNIX, it will open your eyes
to the fact that there is more than one way to do things, and that system administration
can still be simple while modern.</p>

<p><em>Revised with contributions from <a href="http://www.bsdnow.tv">TJ</a> and <a href="https://mike-burns.com">Mike</a>. Thanks!</em></p>

<p>Tags: <a href='tag_software.html'>software</a>, <a href='tag_unix.html'>unix</a></p>








<!-- text end -->
<p id='twitter'><a href='http://twitter.com/intent/tweet?url=http://cfenollosa.com/blog/openbsd-from-a-veteran-linux-user-perspective.html&text=&lt;Type your comment here but please leave the URL so that other people can follow the comments&gt;&via=cfenollosa'>Comments? Tweet</a> 
<a href='https://twitter.com/search?q=http://cfenollosa.com/blog/openbsd-from-a-veteran-linux-user-perspective.html'><span id='count-8960'></span></a>&nbsp;</p>
<script type="text/javascript">$.ajax({type: "GET", url: "https://cdn.api.twitter.com/1/urls/count.json?url=http://cfenollosa.com/blog/openbsd-from-a-veteran-linux-user-perspective.html",
            dataType: "jsonp", success: function(data){ $("#count-8960").html("(" + data.count + ")"); }}); </script>
<h3><a class="ablack" href="filter-tweets-in-safari.html">
Filter tweets in Safari
</a></h3>
<!-- bashblog_timestamp: #201505140820.00# -->
<div class="subtitle">May 14, 2015 &mdash; 
Carlos Fenollosa
</div>
<!-- text begin -->

<p>I've been looking for a Safari extension which filters tweets by keywords for some time. 
Most were abandoned and none of whem worked with the current Twitter layout, so I decided
to learn how to code Safari extensions and see if I could code one.</p>

<p>Writing a Safari extension is simple since Apple provides an Extension Builder within Safari and 
<a href="http://www.macworld.com/article/1156941/safariextension.html">there is a nice tutorial on Macworld</a>
which helped me quite a bit. <a href="https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009977-CH1-SW1">Apple's documentation</a> is good too.</p>

<p>I had to spend about 90% of the time wondering how to retrieve the settings from the extension, which
requires a convoluted process involving message passing between two Javascript classes, but in the end
it seems to work.</p>

<p>It is election time in Spain, so <a href="https://github.com/cfenollosa/SafariFilterTweets">get the extension from Github</a>
and get rid of those pesky political tweets without needing to unfollow anyone!</p>

<p>Tags: <a href='tag_software.html'>software</a></p>








<!-- text end -->
<p id='twitter'><a href='http://twitter.com/intent/tweet?url=http://cfenollosa.com/blog/filter-tweets-in-safari.html&text=&lt;Type your comment here but please leave the URL so that other people can follow the comments&gt;&via=cfenollosa'>Comments? Tweet</a> 
<a href='https://twitter.com/search?q=http://cfenollosa.com/blog/filter-tweets-in-safari.html'><span id='count-20230'></span></a>&nbsp;</p>
<script type="text/javascript">$.ajax({type: "GET", url: "https://cdn.api.twitter.com/1/urls/count.json?url=http://cfenollosa.com/blog/filter-tweets-in-safari.html",
            dataType: "jsonp", success: function(data){ $("#count-20230").html("(" + data.count + ")"); }}); </script>
<h3><a class="ablack" href="creating-an-os-from-scratch.html">
Creating an OS from scratch
</a></h3>
<!-- bashblog_timestamp: #201409291208.00# -->
<div class="subtitle">September 29, 2014 &mdash; 
Carlos Fenollosa
</div>
<!-- text begin -->

<p>I am a Computer Engineer major, so I took some classes in college on how to build
operating systems. For many reasons, I don't remember most of it, but it is a world
which has always excited me.</p>

<p>There has been a <a href="https://news.ycombinator.com/item?id=8380822">recent post on HN</a>
which points to a <a href="http://www.cs.bham.ac.uk/~exr/lectures/opsys/10_11/lectures/os-dev.pdf">very simple and detailed tutorial on how to write an OS
from scratch</a>
and it has really inspired me, so I decided to <a href="https://github.com/cfenollosa/os-tutorial">create a Github repo to publish
the code at the same pace that I learn to write it</a>.</p>

<p>It is not for everyone; rather, for CS/CE majors who were overwhelmed by college
but always were curious about what happens from the moment you turn on your
machine up until when an application loads.</p>

<p>I split each "lesson" into one-concept increments, so it can be easy to follow
for people like me who don't have a lot of time and brain power to learn at a University
pace. This is a work in progress, again, I publish code while I learn and extract it from
the original document and other internet resources, so expect it to be updated
regularly!</p>

<p>Tags: <a href='tag_software.html'>software</a>, <a href='tag_hardware.html'>hardware</a></p>








<!-- text end -->
<p id='twitter'><a href='http://twitter.com/intent/tweet?url=http://cfenollosa.com/blog/creating-an-os-from-scratch.html&text=&lt;Type your comment here but please leave the URL so that other people can follow the comments&gt;&via=cfenollosa'>Comments? Tweet</a> 
<a href='https://twitter.com/search?q=http://cfenollosa.com/blog/creating-an-os-from-scratch.html'><span id='count-22163'></span></a>&nbsp;</p>
<script type="text/javascript">$.ajax({type: "GET", url: "https://cdn.api.twitter.com/1/urls/count.json?url=http://cfenollosa.com/blog/creating-an-os-from-scratch.html",
            dataType: "jsonp", success: function(data){ $("#count-22163").html("(" + data.count + ")"); }}); </script>
<h3><a class="ablack" href="spotify-we-need-to-talk.html">
Spotify, we need to talk
</a></h3>
<!-- bashblog_timestamp: #201406051850.00# -->
<div class="subtitle">June 05, 2014 &mdash; 
Carlos Fenollosa
</div>
<!-- text begin -->

<p>Spotify, I pay you 10 euros every month just for one reason: so that I can listen to my music when I'm in the car.</p>

<p>I'm so glad you exist, you give me a reason not to pirate music. I had expected a service like you for a long time. I used to tell my friends
that "I'll stop pirating when paying gives me a better experience than torrenting". And you did that. I was so happy to pay you every month.
I have convinced at least three people to subscribe to your service, under the premise that they will be able to listen any track, anytime.</p>

<p>Last week, your app was updated again, but since iOS 7, this was done silently. And alas, I jumped into my car to start a road trip,
connected to the bluetooth system, and voila! None of my music was there.</p>

<p>Well, it <em>was</em> there, but it didn't play. Of course offline playlists didn't play. But not even <em>my own local files</em> did play. Ironically,
the only music I could play was the one I hadn't download, thus accessing it via 3G streaming. </p>

<p>This needs to get fixed, right now. In the next release. I mean, not even my local files?! What did you do with them? They are plain mp3 files!</p>

<p>Furthermore, with every release it gets worse. Your engineers spend time making the app "cooler" and enhancing the design, but it works way worse today
on my new phone than two years ago on my old iPhone 3GS. How is that acceptable? Who checks your QA?</p>

<p>If I jump again into my car and you have deleted all my music, I'm back to downloading mp3s and advocating torrenting. Get your stuff together, Spotify.</p>

<p>Tags: <a href='tag_software.html'>software</a>
</p>








<!-- text end -->
<p id='twitter'><a href='http://twitter.com/intent/tweet?url=http://cfenollosa.com/blog/spotify-we-need-to-talk.html&text=&lt;Type your comment here but please leave the URL so that other people can follow the comments&gt;&via=cfenollosa'>Comments? Tweet</a> 
<a href='https://twitter.com/search?q=http://cfenollosa.com/blog/spotify-we-need-to-talk.html'><span id='count-3051'></span></a>&nbsp;</p>
<script type="text/javascript">$.ajax({type: "GET", url: "https://cdn.api.twitter.com/1/urls/count.json?url=http://cfenollosa.com/blog/spotify-we-need-to-talk.html",
            dataType: "jsonp", success: function(data){ $("#count-3051").html("(" + data.count + ")"); }}); </script>
<h3><a class="ablack" href="use-whatsapp-from-the-command-line.html">
Use whatsapp from the command line
</a></h3>
<!-- bashblog_timestamp: #201403101908.00# -->
<div class="subtitle">March 10, 2014 &mdash; 
Carlos Fenollosa
</div>
<!-- text begin -->

<p><i>Update Oct 2014: Whatsapp changed their protocol and third party clients like yoswup may not work
    anymore.</i></p>
<p>In this post I'm going to show you how to run a commandline Whatsapp client. It can be very useful
to connect it to a unix pipe and automatically get messages from your server, via Whatsapp. Also, it's cool B-)</p>

<p>Disclaimer: Whatsapp is sending DMCAs to take down <a href="https://gitorious.org/wazapp-desktop/yowsup">Yowsup's Github repos</a>, so either the software or the
process may break with any update of their protocol. However, to date, I've been using it for a couple of months
with no hassle.</p>

<ol>
<li><a href="https://gitorious.org/wazapp-desktop/yowsup">Download Yoswup from Gitorious</a> and extract it somewhere</li>
<li>Edit the config file and input your cc, phone and id. Leave the password blank</li>
<li>We are going to force a re-auth on your phone's whatsapp in order to cache the password.
Authenticate with yowsup: <code>./yowsup-cli -c config -r sms</code> and wait for the SMS</li>
<li>Second step of the authentication: <code>./yowsup-cli -c config -R [6-digit sms code]</code></li>
<li>Now your phone's Whatsapp is disabled. Open the app and re-auth with either a SMS or a phone call, whatever
is available first. You may have to wait some minutes. </li>
<li>Download <a href="http://www.i-funbox.com">iFunBox</a></li>
<li>Connect your phone, open the iFunBox app in your computer, and navigate to <code>whatsapp/Library/Caches/net.whatsapp.WhatsApp</code></li>
<li>Copy all files named Cache.db* to some place</li>
<li>Download <a href="http://sqlitestudio.pl/?act=download">SQLiteStudio</a></li>
<li>Open SQLiteStudio, and open the database on Cache.db. Navigate to the table <code>cfurl_cache_receiver_data</code> and scroll to the end. You will see a large json string. This is your current authentication data.</li>
<li>Look on the json string for <code>pw:XXXXXXX</code>. That's your password. Copy it to yowsup's config file</li>
<li>We are ready! <code>./yowsup-cli -c config -s [cc][phonenumber] "I'm texting you from a terminal"</code></li>
</ol>

<p>Enjoy! Yowsup can also be used for full conversations, send messages to yourself which you'll receive on your phone or, as mentioned in the beginning of this post, pipe some other command to your phone.</p>

<p>Tags: <a href='tag_software.html'>software</a>, <a href='tag_tricks.html'>tricks</a></p>
</p>








<!-- text end -->
<p id='twitter'><a href='http://twitter.com/intent/tweet?url=http://cfenollosa.com/blog/use-whatsapp-from-the-command-line.html&text=&lt;Type your comment here but please leave the URL so that other people can follow the comments&gt;&via=cfenollosa'>Comments? Tweet</a> 
<a href='https://twitter.com/search?q=http://cfenollosa.com/blog/use-whatsapp-from-the-command-line.html'><span id='count-24218'></span></a>&nbsp;</p>
<script type="text/javascript">$.ajax({type: "GET", url: "https://cdn.api.twitter.com/1/urls/count.json?url=http://cfenollosa.com/blog/use-whatsapp-from-the-command-line.html",
            dataType: "jsonp", success: function(data){ $("#count-24218").html("(" + data.count + ")"); }}); </script>
<h3><a class="ablack" href="sqlite-a-standalone-database-for-your-application.html">
SQLite: a standalone database for your application
</a></h3>
<!-- bashblog_timestamp: #201111101000.00# -->
<div class="subtitle">November 10, 2011 &mdash; 
Carlos Fenollosa
</div>
<!-- text begin -->

<p>Us researchers are used to store data in plain text formats, because it's very
easy to parse and work with. While this is appropriate for some data types&mdash;and,
I'd add, very useful to send later to <tt>R</tt>&mdash;, in some cases disk access is slow or just
inefficient.</p>

<p>This topic is actually very important for some projects, as storing records into a plain text file
is very slow to <i>query</i> afterwards. And this is the key question to ask ourselves before considering
to use a database. Databases are great for complex, unordered queries, but not so great for sequential
access of raw data. Let's see an example.</p>

<p>There is a data file which stores atom coordinates, for example, from a Molecular Dynamics simulation.
This data is very likely to be read once, sequentially, then processed in memory. The information
represents a matrix which will be processed by mathematic functions.
This is the classic example where data files (either binary of plain text) are used correctly.</p>

<p>But now let's think of a list of proteins and some properties, for example, molecular weight
and number of available 3D structures. All these objects are independent, they have their own entity.
While you can store a text file with one line per <tt>&lt;protein, weight, structures&gt;</tt>, it makes
more sense to store it on a database.</p>

<p>Databases allow complex queries to be resolved very quickly. For example,
<i>give me all proteins with molecular weight > 50,000 </i>, <i>list
all proteins which have no crystal structures</i>, or <i>print all the proteins
which have duplicate structures</i>. Were we working with a text file, we would need to process it
completely every time we perform
a query. That's very, very slow. Databases internally store the information in such a way that queries
don't need to go through all elements to get the answer. Namely, they store data on trees by indices.</p>

<p>How do indices work? It's a complex issue but let's think of a very basic example.
Let's say you have three protein structures
<tt>(1BCD, 2KI5, 1AGI)</tt> which you want to index by name and molecular weight.
The system will then automatically build
a protein binary tree where <tt>1BCD</tt> is the parent, the left child is <tt>1AGI</tt> and
<tt>2KI5</tt> is the right child. Then, it will create another tree where the left child is
the lightest protein, the parent is the middle one, and the right child is the heaviest one.</p>

<p>If the index tree is always sorted where the left child is alphabetically
inferior than the parent, and the right child is always superior to the parent, then we can access any
element or group of elements not only without checking every item but also in logarithmic time.
Databases do this once for every index you configure, so complex queries can be solved super fast
because for each of them the system only needs to process a few items of the many millions you might
have stored in the DB. That's because every time you jump to a child element, the system
is avoiding to process half of the database, then a half of this half (1/4), then 1/8, etc.</p>

<p>To summarize, if you have some data where each record has its own entity (i.e. can be thought of
as an "object") and you think you'll make queries which retrieve an arbitrary number of the
elements, then you need to use a database. Databases have even more advantages, like relationships
between objects (e.g. each crystal structure has its own entity, and can be related to a protein), but
database design is a complex topic and this article will cover only the basic data storage.</p>

<p>However, databases are usually configured by the system administrator and
handled by a daemon&mdash;<tt>oracle</tt>, <tt>mysql</tt>, <tt>postgresql</tt>. Here I will talk about
yet another way of creating databases, without the need to start any daemons, have any user privileges
and, more importantly, easily portable. This is done via <tt>sqlite</tt>.</p>

<p><a href="http://www.sqlite.org/index.html">SQLite</a>
is a library that implements a SQL engine inside your own application. This means that while
the database is persistent inside a file, all the querying infrastructure is deployed along with your
code and stopped when the code finishes running. The databases can be created very easily, making it
easy to have multiple DBs for testing, and without the need to bother the system administrator.</p>

<p><tt>sqlite</tt> has bindings for almost all popular languages and also a commandline interface
which is handy for testing and debugging. The data is stored on a single file which can be deployed
with your application without needing to install any standalone servers. Obviously, it is not a
replacement for Oracle's solutions, but it can speed up a lot some applications which need to work
querying data and don't have access to one.</p>

<p>Most popular software uses some kind of database to store data, as this is a super fast way to
access preferences and other items. For scientific programs, it is always necessary
to think twice before using one, as database design is an art on its own, and as said before,
it does not suit all needs.</p>

<p>When used properly, a small ad-hoc database like <tt>sqlite</tt> can speed up
software, make data access very easy and allow the manipulation of large, objectified,
in-related data collections with simple queries instead of writing long and slow algorithms
which process all the data when you only need one item.</p>

<p>Tags: <a href="tag_software.html">software</a>, <a href="tag_programming.html">programming</a></p>








<!-- text end -->
<p id='twitter'><a href='http://twitter.com/intent/tweet?url=http://cfenollosa.com/blog/sqlite-a-standalone-database-for-your-application.html&text=&lt;Type your comment here but please leave the URL so that other people can follow the comments&gt;&via=cfenollosa'>Comments? Tweet</a> 
<a href='https://twitter.com/search?q=http://cfenollosa.com/blog/sqlite-a-standalone-database-for-your-application.html'><span id='count-13686'></span></a>&nbsp;</p>
<script type="text/javascript">$.ajax({type: "GET", url: "https://cdn.api.twitter.com/1/urls/count.json?url=http://cfenollosa.com/blog/sqlite-a-standalone-database-for-your-application.html",
            dataType: "jsonp", success: function(data){ $("#count-13686").html("(" + data.count + ")"); }}); </script>
</div>
<div id="footer">CC by-nc-nd 2008-2016 <a href="http://cfenollosa.com">Carlos Fenollosa</a> &mdash; <a href="mailto:cf&#64;cfenollosa&#46;com">cf&#64;cfenollosa&#46;com</a><br/>
Generated with <a href="https://github.com/cfenollosa/bashblog">bashblog</a>, a single bash script to easily create blogs like this one<br/>
<a href="../cookies.html">Cookies policy</a> &mdash; <a href="the-ignorant-eu-cookie-law.html">Learn why this cookies law is ignorant</a></div>
</div></div>
</body></html>
