<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel><title>Carlos Fenollosa &#x2014; Blog</title><link>http://cfenollosa.com/blog/index.html</link>
<description>Thoughts on science and tips for researchers who use computers</description><language>en</language>
<lastBuildDate>Sat, 20 Aug 2016 13:06:39 +0200</lastBuildDate>
<pubDate>Sat, 20 Aug 2016 13:06:39 +0200</pubDate>
<atom:link href="http://cfenollosa.com/blog/feed.rss" rel="self" type="application/rss+xml" />
<item><title>
Basic iPhone security for regular people
</title><description><![CDATA[

<p>Real life requires a balance between convenience and security. 
You might not be a high-profile person, but we all have personal information on our phones which can give us
a headache if it falls into the wrong hands.</p>

<p>Here are some options you can enable to harden your iPhone in the case of theft, a targeted attack or just
a curious nephew who's messing with your phone.</p>

<p>Even if you don't enable them all, it's always nice to know
that these features exist to protect your personal information. This guide is specific for iPhones, but 
I suppose that most of them can be directly applied to other phones.</p>

<h4>Password-protect your phone</h4>

<p>Your iPhone must always have a password. Otherwise, anybody with physical access to your phone 
will get access to all your information: calendar, mail, pictures or <i>*gasp*</i> browser history.</p>

<p>Passwords are inconvenient. However, even 
a simple 4-digit code will stop casual attackers, though <a href="https://www.intego.com/mac-security-blog/iphone-pin-pass-code/">it is not secure against a resourceful attacker</a></p>

<p><b>&#9745; Use a password on your phone: <code>Settings &gt; Touch ID &amp; Passcode</code></b></p>

<p>Furthermore, enable the 10-attempt limit, so that people can't brute-force your password. </p>

<p><b>&#9745; Erase data after 10 attempts: <code>Settings &gt; Touch ID &amp; Passcode &gt; Erase data (ON)</code></b></p>

<p>If your phone has Touch ID, enable it, and use a very long and complicated password to unlock your phone.
You will only need to input it on boot and for a few options. It is reasonably secure and
has few drawbacks for most users. Unless you have specific reasons not to do it, just go and enable Touch ID.</p>

<p><b>&#9745; Enable Touch ID: <code>Settings &gt; Touch ID &amp; Passcode</code></b></p>

<p>Regarding password input, and especially if your phone doesn't have Touch ID, using a numeric keyboard is
much faster than the QWERTY one. Here's a trick that will help you choose a secure numeric password
which is easy to remember.</p>

<p>Think of a word and convert it to numbers as if you were
dialing them on a phone, i.e. ABC -> 2, DEF -> 3, ..., WYZ -> 9. 
For example, if your password is "PASSWORD", the numeric code would be 72779673.</p>

<p>The iPhone will automatically detect that the password contains only numbers and will present a digital keyboard
on the lock screen instead of a QWERTY one, making it super easy to remember and type while still keeping
a high level of security.</p>

<p><b>&#9745; If you must use a numeric password, use a long one: <code>Settings &gt; Touch ID &amp; Passcode</code></b></p>

<h4>Harden your iPhone when locked</h4>

<p>A locked phone can still leak private data. Accessing Siri, the calendar or messages from the lock screen
is handy, but depending on your personal case, can give too much information to a thief or attacker.</p>

<p>Siri is a great source of data leaks, and I recommend that you disable it when your phone is locked. It will
essentially squeal your personal info, your contacts, tasks or events. A thief can easily know everything
about you or harass your family if they get a hand on a phone with Siri enabled on the lock screen.</p>

<p>This setting does not disable Siri completely; it just requires the phone to be unlocked for Siri to work.</p>

<p><b>&#9745; Disable Siri when phone is locked: <code>Settings &gt; Touch ID &amp; Passcode &gt; Siri</code></b></p>

<p>If you have confidential data on your calendar, you may also want to disable the "today" view which usually includes
your calendar, reminders, etc.</p>

<p><b>&#9745; Disable Today view: <code>Settings &gt; Touch ID &amp; Passcode &gt; Today</code></b></p>

<p>Take a look at the other options there. You may want to turn off the notifications view, or the option to reply with
a message. An attacker may spoof your identity by answering messages while the phone is locked, for example,
taking advantage from an SMS from "Mom" and tricking her into asking for her maiden name, pet names, etc., which are usually
answers to secret questions to recover your password.</p>

<p><b>&#9745; Disallow message replies when the phone is locked: <code>Settings &gt; Touch ID &amp; Passcode &gt; Reply with Message</code></b></p>

<p>Having your medical information on the emergency screen has pros and cons. Since I don't have any dangerous conditions,
I disable it. Your case may be different.</p>

<p>Someone with your phone can use Medical ID to get your name and picture, which may be googled for identity theft
or sending you phishing emails. Your name can also be searched for public records or DNS whois information,
which may disclose your home phone, address, date of birth, ID number and family members.</p>

<p>In summary, make it sure that somebody who finds your locked phone cannot discover who you are or interact as if they
were you. </p>

<p><b>&#9745; Disable Medical ID: <code>Health &gt; Medical ID &gt; Edit &gt; Show When Locked</code></b></p>

<p>Some people think that letting anyone find out the owner of the phone is a good idea,
since an honest person who finds your lost phone can easily contact you. However,
you can always display a personalized message on your lock screen if you report your phone missing on iCloud.</p>

<p><b>&#9745; Enable "Find my phone": <code>Settings &gt; iCloud &gt; Find my iPhone &gt; Find My iPhone</code></b></p>

<p>Make sure that your phone will send its location just before it runs out of battery</p>

<p><b>&#9745; Enable "Find my phone": <code>Settings &gt; iCloud &gt; Find my iPhone &gt; Send Last Location</code></b></p>

<p>To finish this section, if you don't have the habit of manually locking your phone after you use it, or before
placing it in your pocket, configure your iPhone to do it automatically:</p>

<p><b>&#9745; Enable phone locking: <code>Settings &gt; General &gt; Auto-Lock</code></b></p>

<h4>Harden the hardware</h4>

<p>Your phone is now secure and won't sing like a canary when it gets into the wrong hands.</p>

<p>However, your SIM card may. SIMs can contain personal information, like names, phones or addresses, so
they must be secured, too. </p>

<p>Enable the SIM lock so that, on boot, it will ask for a 4-digit code besides your phone password. It may sound
annoying, but it isn't. It's just an extra step that you only need to perform once every many days, when
your phone restarts.</p>

<p>Otherwise, a thief
can stick the SIM in another phone and access that information and discover your phone number. With it, you may
be googled, or they may attempt phishing attacks weeks later.</p>

<p>Beware that this strategy doesn't allow the phone to ping home after it has been shut down and turned on.</p>

<p><b>&#9745; Enable SIM PIN: <code>Settings &gt; Phone &gt; SIM PIN</code></b></p>

<p>Enable iCloud. When your phone is associated with an iCloud account, it is impossible
for another person to use it, dropping its resale value to almost zero. I've had some friends get their phones back
after a casual thief tried to sell them unsuccessfully thanks to the iCloud lock and finally decided to do the good thing
and return it.</p>

<p><b>&#9745; Enable iCloud: <code>Settings &gt; iCloud</code></b></p>

<p>If you have the means, try to upgrade to an iPhone 5S or higher. These phones contain a hardware element called
<em>Secure Enclave</em> which encrypts your personal information in a way that can't even be cracked <a href="https://9to5mac.com/2016/04/07/fbi-iphone-hack-method-secure-enclave/">by the FBI</a>. If your phone
gets stolen by a professional, they won't be able to solder the flash memory into another device and recover your data.</p>

<p><b>&#9745; Upgrade to a phone with a Secure Enclave (iPhone 5S or higher)</b></p>

<h4>Harden your online accounts</h4>

<p>In reality, your online data is much more at risk than your physical phone. 
Botnets constantly try to find vulnerabilities in services and steal user passwords.</p>

<p>The first thing you must do right now is to install a password manager. Your iPhone has one built into the system,
which is good enough to generate unique password and auto-fill them when needed.</p>

<p>If you don't like Apple's Keychain, I recommend <a href="https://lastpass.com/f?8040546">LastPass</a> and <a href="https://1password.com">1Password</a>.</p>

<p>Why do you need a password manager? The main reason is to avoid having a single password for all services.
The popular trick of <em>having a weak password for most sites and another strong password for important sites</em>
is a dangerous idea.</p>

<p>Your goal is to have a different password for each site/service, so that if it gets attacked or you
inadvertently leak it to a phishing attack, it is no big deal and doesn't affect all your accounts.</p>

<p>Just have a different one for each service and let the phone remember all of them. I don't know
my passwords: Gmail, Facebook, Twitter, my browser remembers them for me.</p>

<p><b>&#9745; Use a password manager: <code>Settings &gt; iCloud &gt; Keychain &gt; iCloud Keychain</code></b></p>

<p>There is another system which complements passwords, called "Two-Factor Authentication", or 2FA. You have probably used it
in online banking; they send you an SMS with a confirmation code that you have to enter somewhere.</p>

<p>If your password gets stolen, 2FA is a fantastic barrier against an attacker. Without your phone, they can't
access your data, even if they have all your passwords.</p>

<p><b>&#9745; Use 2FA for your online accounts: <a href="https://www.turnon2fa.com">manual for different sites</a></b></p>

<p>2FA makes it critical to disable SMS previews, because if a thief steals your phone and already has
some of your passwords, he can use your locked phone to read 2FA SMS. </p>

<p>If you use iMessage heavily, this may be cumbersome, so decide for yourself.</p>

<p><b>&#9745; Disable SMS previews on locked phone: <code>Settings &gt; Notifications &gt; Messages &gt; Show Previews</code></b></p>

<h4>Make it easy to recover your data</h4>

<p>If the worst happens, and you lose your phone, get it stolen or drop it on the Venice canals, plan ahead so that
the only loss is the money for a new phone. You don't want to lose your pictures, passwords, phone numbers,
events...</p>

<p>Fortunately, iPhones have a phenomenal backup system which can store your phone data in the cloud or your Mac.
I have a Mac, but I recommend the iCloud backup nonetheless.</p>

<p>Apple only offers 5 GB of storage in iCloud, which is poor, but fortunately, the pricing tiers are fair. 
For one or two
bucks a month, depending on your usage,
you can buy the cheapest and most important digital insurance to keep all your data and pictures safe.</p>

<p>iCloud backup can automatically set up a new phone and make it behave exactly like your old phone.</p>

<p>If you own a Mac, once you pay for iCloud storage, 
you can enable the "iCloud Photo Library" on <code>Settings &gt; iCloud &gt; Photos &gt; 
iCloud Photo Library</code> for transparent syncing of all your pictures between your phone and your computer.</p>

<p><b>&#9745; Enable iCloud backup: <code>Settings &gt; iCloud &gt; Backup &gt; iCloud Backup</code></b></p>

<p>If you don't want the iCloud backup, at least add a free iCloud account or any other "sync" account like 
Google's, and use it to store your contacts,
calendars, notes and Keychain.</p>

<p><b>&#9745; Enable iCloud: <code>Settings &gt; iCloud</code></b></p>

<h4>Bonus: disable your phone when showing pictures</h4>

<p>Afraid of handing your phone over to show somebody a picture? People have a tendency to swipe around to see
other images, which may be a bad idea in some cases.</p>

<p>To save them from seeing things that can't be unseen, you can use a trick with the Guided Access feature to lock
all input to the phone, yet still show whatever is on the screen.</p>

<p><b>&#9745; Use Guided Access to lock pictures on screen: <a href="http://www.macworld.com/article/2989977/operating-systems/guided-access-can-disable-photos-delete-and-other-app-features.html">Read this manual</a></b></p>

<h4>This is not a thorough guide</h4>

<p>As the title mentions, this is an essential blueprint for iPhone users who are not a serious target for digital theft.
High-profile people need to take many more steps to secure their data. Still, they all implement these options too.</p>

<p>The usual scenario for a thief who steals your phone at a bar is as follows: they will turn it off or put it in airplane
mode and try to unlock it. Once they see that it's locked with iCloud, they can either try to sell it for parts, return
it or discard it.</p>

<p>Muggers don't want your data. However, it doesn't hurt to implement some security measures.</p>

<p>In worse scenarios, there are criminal companies specialized in buying stolen phones at a very low price 
and <a href="https://hackernoon.com/this-is-what-apple-should-tell-you-when-you-lose-your-iphone-8f07cf73cf82#.b7qy5dt2f">perform massive simple attacks</a> to unsuspecting users to trick them into unlocking the phone or giving
up personal data. </p>

<p>You don't need the same security as Obama or Snowden. Nonetheless, 
knowing how your phone leaks personal information and the possible 
attack vectors is important in defending yourself from prying eyes.</p>

<p>You have your whole life on your phone. In the case of an unfortunate theft, make it so the only loss is the cost
of a new one.</p>

<p>Tags: <a href='tag_security.html'>security</a></p>

<!-- text end -->
<p id='twitter'><a href='http://twitter.com/intent/tweet?url=http://cfenollosa.com/blog/basic-iphone-security-for-regular-people.html&text=&lt;Type your comment here but please leave the URL so that other people can follow the comments&gt;&via=cfenollosa'>Comments? Tweet</a> 
<a href='https://twitter.com/search?q=http://cfenollosa.com/blog/basic-iphone-security-for-regular-people.html'><span id='count-31476'></span></a>&nbsp;</p>
<script type="text/javascript">$.ajax({type: "GET", url: "https://cdn.api.twitter.com/1/urls/count.json?url=http://cfenollosa.com/blog/basic-iphone-security-for-regular-people.html",
            dataType: "jsonp", success: function(data){ $("#count-31476").html("(" + data.count + ")"); }}); </script>
]]></description><link>http://cfenollosa.com/blog/basic-iphone-security-for-regular-people.html</link>
<guid>http://cfenollosa.com/blog/./basic-iphone-security-for-regular-people.html</guid>
<dc:creator>Carlos Fenollosa</dc:creator>
<pubDate>Thu, 18 Aug 2016 18:21:21 +0200</pubDate></item>
<item><title>
Living in a disrupted economy
</title><description><![CDATA[

<p>There is this continuing discussion on whether technology destroys more jobs than it creates. Every few years, yet another tech revolution occurs, journalists publish articles, pundits share their opinions, politicians try to catch up, and those affected always voice their concerns. These couple years have been no exception, thanks to Uber, Airbnb, and the called <a href="https://en.wikipedia.org/wiki/Sharing_economy">sharing economy</a>.</p>

<p>I'm a technologist and a relatively young person, so I am naturally biased towards technological disruption. After all, it is people like me who are trying to make a living by taking over older jobs.</p>

<p>I suggest that you take a few minutes to read a fantastic article titled <a href="http://www.sleuthsayers.org/2013/06/the-3500-shirt-history-lesson-in.html">The $3500 shirt</a>.
That essay reveals how horrible some industries were before they could be automated or replaced by something better. Go on, please read it now, it will only take three minutes.</p>

<p>Now, imagine you had to spend a couple of weeks of your time to make a t-shirt from scratch. Would that be acceptable? I guess we all more or less agree that the textile revolution was a net gain for society. Nevertheless, when it occurred, some Luddites probably complained, arguing that the loom put seamstresses out of work.</p>

<p>History is packed with dead industries. We killed the ice business with the modern fridge. We burn less coal for energy, so miners go unemployed. And let's not forget the basis of modern civilization, the agricultural revolution, which is the only reason us humans can feed ourselves. Without greenhouses, nitrates, tractors, pest protection and advancements in farming, humanity would starve.</p>

<p>Admittedly, it transformed the first sector from a 65% in workforce quota into <a href="https://en.wikipedia.org/wiki/Three-sector_theory">the current 10%</a>. Isn't it great that most of us don't need to wake up before sunrise to water our crops? In hindsight, can you imagine proclaiming that the 1800s way of farming is better because it preserves farming jobs?</p>

<p>The bottom line is that all economic transformations are a net gain for society. They may not be flawless, but they have allowed us humans to live a better life.</p>

<p>So why do some characters fight against current industry disruptions if history will prove them wrong?</p>

<div style="text-align: center">******</div>

<p>As a European and a social democrat, I believe that States must regulate some economies to avoid monopolies and abuses, supporting the greater good. Furthermore, I sympathize with the affected workforce, both personally and in a macroeconomic level. All taxi drivers suddenly going jobless because of Uber is detrimental to society.</p>

<p>However, it pains me to see that European politicians are taking the opposite stance, brandishing law and tradition as excuses to hinder progress.</p>

<p>Laws must serve people, not the other way around. If we analyze the taxi example, we learn that there is a regulation which requires taxi drivers to pay a huge sum of money up front to operate. Therefore, letting anybody get in that business for free is unfair and breaks the rules of the game. Unsurprisingly, this situation is unfair not because of the new players, but because that regulation is obsolete.</p>

<p>It isn't ethically right that somebody who spent a lot of money to get a license sees their job at risk. But the solution isn't to block other players, especially when it's regulation which is at fault. Let's sit down, think how to establish a transition period, and maybe even reimburse drivers part of that money with the earnings from increased taxes due to a higher employment and economic activity.</p>

<p>There is a middle ground solution: don't change the rules drastically, but don't use these them as an excuse to impede progress.</p>

<p>At the end of the day, some careers are condemned to extinction. That is a real social drama, however, what should we do? Artificially stop innovation to save jobs which are not efficient and, when automated or improved, they make the world better for everyone?</p>

<div style="text-align: center">******</div>

<p>Us millennials have learned that the concept of a single, lifetime profession just does not exist anymore. Previous generations do not want to accept that reality. I understand that reconverting an older person to a new career may be difficult, but if the alternative is letting that person obstruct younger people's opportunities, that's not fair.</p>

<p>Most professions decline organically, by the very nature of society and economy. It is the politicians' responsibility to mediate when this process is accelerated by a new industry or technology. New or automated trades will take their place, usually providing a bigger collective benefit, like healthcare, education, or modern farming.</p>

<p>Our duty as a society is to make sure everyone lives a happy and comfortable life. Artificially blocking new technologies and economic models harms everyone. If it were for some Luddites, we'd be still paying $3500 for a shirt, and that seamstress would never have been a nurse or a scientist.</p>

<p>Tags: <a href='tag_law.html'>law</a>, <a href='tag_startups.html'>startups</a></p>

<!-- text end -->
<p id='twitter'><a href='http://twitter.com/intent/tweet?url=http://cfenollosa.com/blog/living-in-a-disrupted-economy.html&text=&lt;Type your comment here but please leave the URL so that other people can follow the comments&gt;&via=cfenollosa'>Comments? Tweet</a> 
<a href='https://twitter.com/search?q=http://cfenollosa.com/blog/living-in-a-disrupted-economy.html'><span id='count-8297'></span></a>&nbsp;</p>
<script type="text/javascript">$.ajax({type: "GET", url: "https://cdn.api.twitter.com/1/urls/count.json?url=http://cfenollosa.com/blog/living-in-a-disrupted-economy.html",
            dataType: "jsonp", success: function(data){ $("#count-8297").html("(" + data.count + ")"); }}); </script>
]]></description><link>http://cfenollosa.com/blog/living-in-a-disrupted-economy.html</link>
<guid>http://cfenollosa.com/blog/./living-in-a-disrupted-economy.html</guid>
<dc:creator>Carlos Fenollosa</dc:creator>
<pubDate>Thu, 21 Jul 2016 16:58:39 +0200</pubDate></item>
<item><title>
The Elixir of concurrency
</title><description><![CDATA[

<p><a href="http://elixir-lang.org">Elixir</a> is a <a href="https://en.wikipedia.org/wiki/Elixir_(programming_language)">fairly young</a> language that was born when <a href="https://github.com/josevalim">José and a few Rails developers</a>
tried to create a modern language optimized for concurrent, distributed, lightweight processes</p>

<p>They wanted a modern Ruby-like syntax with a well-tested process manager, the <a href="https://en.wikipedia.org/wiki/Erlang_(programming_language)">Erlang VM</a>.
The result is Elixir, defined as <em>a dynamic, functional language designed for building scalable and maintainable applications</em>,
a correct but vague affirmation which doesn't do justice to its power and elegancy.</p>

<p>I recently <a href="https://lobste.rs/s/pej1vc/moving_away_from_python_2/comments/1txpzt#c_1txpzt">compared</a> the move to Elixir from Python as a similar leapfrog to
moving to Python from Java. It feels like something new, modern, powerful, with killer features that you don't want to
renounce to. </p>

<p>In Python I found a REPL, list comprehensions, a super clean syntax and decorators. Elixir brings lightweight supervised
processes, pattern matching, a fully functional programming language, pipes and a terrific build tool: <code>mix</code></p>

<p>If you've never written functional code, the jump is significant. I took a <a href="https://www.coursera.org/course/progfun">Scala course</a> a couple years ago
and I've needed almost two full weeks to write production code in Elixir. The language is young, Stack Overflow is of no help
&mdash;no kidding, that is a big deal&mdash;, and there are few libraries in Github.</p>

<p>A small community also comes with some upsides: people are more motivated and willing to help, centralized tools like forums
and IRC channels are still manageable, and you may even suggest changes to the language for upcoming versions.</p>

<h4>What is Elixir for?</h4>

<p>I had a middle school teacher who said that you can't define something by stating <em>what is't not</em>. However, in programming,
mentioning use cases which are not suitable for the language is a good way to start.</p>

<p>Elixir is probably not the first choice for single core software: math calculus, CPU-intensive apps or desktop applications. 
Since it's very high level, systems programming is also out of the picture.</p>

<p>Elixir is great for web applications, standalone or using the <a href="http://www.phoenixframework.org">Phoenix framework</a> &mdash;Elixir's Rails&mdash;. 
It really shines for building highly scalable, fault-tolerant network applications, like chats, telecommunications or
generic web services.</p>

<p>Why is that? Thanks to the Erlang VM, processes are really tiny, each one is garbage collected with a low latency,
they communicate by sending location-independent messages over the network using the VMs 
(you can run <code>result = Machine2.Module.function(params)</code> on Machine1),
and spawning and managing these processes is effortless thanks to some of its abstractions.</p>

<p>Finally, Elixir's basic modules also shine: <code>Plug</code> and <code>Router</code> for managing HTTP requests, <code>Ecto</code> for relational databases and
<code>ETS</code> and <code>Mnesia</code> for distributed in-memory databases. </p>

<p>Many recommend Elixir if only for Phoenix, but I found that for most backend applications it is enough to use <code>Plug</code> and <code>Router</code>.
Phoenix is impressive but I believe it's a mistake to jump right into it without trying the base modules first, so my recommendation for 
beginners is to hold on Phoenix until you really need it.</p>

<p>Elixir's novelty, the pipe operator, is a fantastic approach to working with state in a functional manner. Instead of running 
<code>readlines(fopen(user_input(), "r")).uppercase().split()</code>, try the more readable <code>user_input |&gt; fopen("r") |&gt; readlines |&gt; uppercase |&gt; split</code>.</p>

<p>It is a language which was clearly designed to stand on the shoulders of giants, while providing modern capabilities
for developers.</p>

<h4>Elixir's abstractions</h4>

<p>To store centralized &lt;key, value&gt;-like data, instead of a Singleton, 
Elixir's provides an <code>Agent</code>. It keeps state in memory and many processes can access and modify it without concurrency issues.</p>

<p>The language can spawn processes much like threads, using <code>spawn_link</code>, but you probably don't want to do that. You'd
rather use a <code>Task</code>, which is basically <code>async/await</code>, or a <code>Gen(eric)Server</code>, a very cool abstraction that receives requests
from other processes, spawns helper mini-servers and processes the results in parallel, for free.</p>

<p>All tasks can be controlled using the <code>Supervisor</code>, which holds other abstractions as its "children" and automatically restarts
them when they crash.</p>

<p>Finally, your code is contained inside a single <code>project</code> which can manage different <code>apps</code>, with modules that hold functions. 
No packages, no classes, no objects. Modules, functions, structs and basic data types.</p>

<p>Dependency management is
straightforward thanks to <code>mix</code>; builds and testing are handled by <code>mix</code> too. As opposed to other multi-tools like <code>gradle</code>, this
one is really fast.</p>

<p>Is that too much to process? I felt that at first, too. Give it some time and your brain will eventually think in terms of
<code>Supervisor</code>s which manage <code>GenServer</code>s which spawn <code>Agent</code>s and <code>Task</code>s when needed.</p>

<h4>Let it crash</h4>

<p>Elixir's mantra is to let processes crash. I found it shocking and counter-intuitive, but with some explanation it makes a lot of sense.</p>

<p>Neither developers want their code to crash nor Elixir promotes writing bad code. 
However, let's agree that there are
many reasons besides bad programming which can make a software crash. 
If we have a server which runs stuff and at some point we have, say, 100 connections every second, one might crash eventually
because of a bug in any component, hardware issues, a cosmic ray, or Murphy's law.</p>

<p>The question is: in the event of an unfortunate, unavoidable crash, how will your system react?</p>

<ol>
<li>Bring everything down?</li>
<li>Try to capture the error and recover?</li>
<li>Kill the crashed process and launch another one in its place?</li>
</ol>

<p>For example, C uses approach 1. Most modern languages with Exceptions like Java and Python use 2. 
Elixir uses 3. This is not suitable for all environments, but it is
perfect for those use cases which fit Elixir: concurrent network processes.</p>

<p>With Elixir, a single failure never brings the system down. What's more, it automatically restarts the crashed process, so the 
client can instantly retry and, unless there is a reproducible bug in your code, the fresh process will finish without an issue.</p>

<p>The bottom line is: a single client may be unlucky and crash at some point, but the rest of the system will never notice.</p>

<h4>How to start?</h4>

<p>Let's get our hands dirty. After reading many sites, watching hours of video and following a dozen tutorials, here are the resources
I found the most valuable. I'd suggest following this order.</p>

<p><strong>Getting started</strong></p>

<ol>
<li><a href="https://www.youtube.com/watch?v=dZV4_uNw72A">Madrid Elixir Meetup 2016-03</a>. If you understand Spanish, this is the best intro to Elixir. Otherwise, watch 
<a href="https://www.youtube.com/watch?v=5kYmOyJjGDM">All aboard the Elixir Express!</a> which is a bit outdated but very comprehensive.</li>
<li><a href="http://elixir-lang.org/getting-started/introduction.html">Official "Getting Started" guide</a>. It's the best and the most current. Follow it from start to finish, including the 
advanced chapters.</li>
<li><a href="https://elixirschool.com">Elixir School</a>. A nice complement to the official guide. Most things are very similar, but the different approach
on OTP will help you understand it better.</li>
<li><a href="https://medium.com/@StevenLeiva1/understanding-elixir-s-genserver-a8d5756e6848#.a2yytqrbe">Understanding Elixir's GenServer</a> and <a href="https://medium.com/@StevenLeiva1/elixir-supervisors-a-conceptual-understanding-ee0825f70cbe#.zbyjhdg0u">Elixir's supervisors, a conceptual understanding</a> are two short reads
with yet another explanation of OTP features.</li>
<li><a href="https://www.dropbox.com/s/lr1t87rw4wfnyb3/elixir-cheat-sheet-v2.pdf?dl=0">Elixir Cheat Sheet</a>. The best one out there</li>
</ol>

<p><strong>First projects</strong></p>

<ol>
<li><a href="https://github.com/gregpardo/vim-elixir-ide">vim-elixir-ide</a>. Elixir support for <code>vim</code>, not the best plugin but suitable for beginners.</li>
<li><a href="https://elixir-examples.github.io">Elixir examples</a>. The Elixir guide covers all these, but it's handy to have common idioms on a single page: "string to list", "concatenate list", "optional function parameters", etc.</li>
<li><a href="http://howistart.org/posts/elixir/1">Portal Game by José Valim</a>. A complement to the sample project on the official guide.</li>
<li><a href="http://elixirkoans.io">Elixir Koans</a> and <a href="http://exercism.io/languages/elixir">Exercism</a> are mini exercises that you can use to improve your Elixir agility. On the same line,
<a href="http://elixirgolf.com">Elixir Golf</a> proposes weekly puzzles to solve.</li>
<li><a href="http://learningelixir.joekain.com">Learning Elixir</a>. Joseph Kain has a ton of content with mini projects and examples you can follow. Top quality. </li>
<li><a href="https://excasts.com/episodes">Excasts</a> and <a href="http://elixirsips.com/">Elixir sips</a> have short screencasts that you can check out for reference</li>
<li><a href="https://www.youtube.com/playlist?list=PLWbHc_FXPo2gB7HUE-2H61HAEyszAph3H">ElixirConf videos</a> contain very interesting talks which may be overwhelming for beginners, but are worth
a look later on.</li>
<li><a href="https://gist.github.com/likethesky/abb00e5aedc38ee9f711">Install Elixir and Phoenix on OSX</a>. If you want to use Phoenix on OSX, you may need this help</li>
<li><a href="http://www.phoenixframework.org/docs/overview">Phoenix Official Guide</a>. Phoenix isn't necessary for simple web services, you can use <code>Plug</code>. But for 
large projects you'll need a framework. Nothing like the official guide.</li>
</ol>

<p><strong>Getting help</strong></p>

<ol>
<li><a href="https://github.com/h4cc/awesome-elixir">Awesome Elixir</a>. A list of Elixir resources, where I found many of these.</li>
<li><a href="https://twitter.com/ElixirTip">Elixir Tip</a> and <a href="https://twitter.com/elixirstatus">Elixir Status</a> regularly link to Elixir-related articles and videos, and 
<a href="http://blog.plataformatec.com.br/tag/elixir/">Plataformatec Elixir posts</a> is where the language authors share news and tips.</li>
<li>If you have questions about code, try the <a href="http://elixirforum.com">Elixir forum</a> first, the <a href="irc://irc.freenode.net/elixir-lang">IRC channel</a>
or <a href="https://elixir-slackin.herokuapp.com/">Slack</a>. The developers would like to transition all help requests out of the <a href="https://groups.google.com/group/elixir-lang-talk">Mailing list</a>,
which you can use for language-related discussions.</li>
<li><a href="https://www.reddit.com/r/elixir">/r/elixir</a> if you're into Reddit</li>
</ol>

<h4>Closing thoughts</h4>

<p>I think that's all for the moment. I hope this post can help some beginners to get their hands on the language and start
writing production code as soon as possible. </p>

<p>For anyone who wants to know what's all the Elixir fuss about, it's difficult to explain, especially for somebody like me
who has been programming in imperative languages all his life.</p>

<p>When I recommended Elixir to a friend, he replied, "A highly concurrent, functional language using the Erlang VM? 
Don't you have something more exotic?". That's right. Elixir is exotic and use-case specific. </p>

<p>Unlike Python, which is my favorite imperative language and ecosystem, I can't recommend Elixir for everyone.
Not everybody can spare a couple weeks to get started. Many libraries for common use cases are missing: 
there is nothing
equivalent to Numpy or Matplotlib, and modern
applications are built on top of dozens of libs, not everyone has the time or will to write library code.
Fortunately, at <a href="http://paradoxa.io">Paradoxa</a> I am my own boss and I make the tech decisions :)</p>

<p>For hackers or tinkerers it's definitely worth a look, it "won't change your perspective" like Lisp, but
it will make you see that writing concurrent code doesn't need to be difficult, and that better tooling is definitely possible.</p>

<p>I bet Elixir will be the foundation of most devops stacks in a few years, when developers realize that the 
future's bottleneck won't be the CPU, but rather the number of concurrent processes and connections your backend can manage.
With Elixir you only need to boot another machine in your network and let the exotic Erlang VM handle the rest.</p>

<p>Tags: <a href='tag_programming.html'>programming</a>, <a href='tag_learning.html'>learning</a></p>

<!-- text end -->
<p id='twitter'><a href='http://twitter.com/intent/tweet?url=http://cfenollosa.com/blog/the-elixir-of-concurrency.html&text=&lt;Type your comment here but please leave the URL so that other people can follow the comments&gt;&via=cfenollosa'>Comments? Tweet</a> 
<a href='https://twitter.com/search?q=http://cfenollosa.com/blog/the-elixir-of-concurrency.html'><span id='count-19356'></span></a>&nbsp;</p>
<script type="text/javascript">$.ajax({type: "GET", url: "https://cdn.api.twitter.com/1/urls/count.json?url=http://cfenollosa.com/blog/the-elixir-of-concurrency.html",
            dataType: "jsonp", success: function(data){ $("#count-19356").html("(" + data.count + ")"); }}); </script>
]]></description><link>http://cfenollosa.com/blog/the-elixir-of-concurrency.html</link>
<guid>http://cfenollosa.com/blog/./the-elixir-of-concurrency.html</guid>
<dc:creator>Carlos Fenollosa</dc:creator>
<pubDate>Mon, 23 May 2016 19:55:55 +0200</pubDate></item>
<item><title>
Bots lack metaphors, and that is their biggest asset
</title><description><![CDATA[

<p>Bots are the hot topic this 2016. They need no presentation, so I'm not going to introduce
them. Let's get to the point.</p>

<p>We can all agree that bots are an interesting idea. However, 
there's this debate regarding whether 
bots are going to be the user interface of the future.</p>

<p>Many critics argue against a future where bots rule user interaction. Some are philosophical,
others are somehow short-sighted, and many are just contrarian <em>per se</em>.</p>

<p>I'm not saying they're
wrong, but they overlook some strong arguments that we should have learned by observing the history of computing.</p>

<h4>What computer history taught us</h4>

<p>The most important thing we learned since the 70s is that 
people do not want quicker and faster interfaces, they want <em>better</em> interfaces. </p>

<p>In the 80s, during the GUI revolution, they had critics too. GUI detractors claimed that
<a href="http://www.sitepoint.com/real-history-gui/">the GUI was just a gimmick</a>, or that
<a href="https://en.wikipedia.org/wiki/No_true_Scotsman">real computer users</a> preferred the command line.
We should know better by now.</p>

<p>Critics were right in some points: GUIs weren't faster or more potent than the command line. However, this wasn't the winning argument.</p>

<p>GUIs won because the general public will always prefer a tool that is easier to use and understand
than one which is more powerful but harder to use.</p>

<h4>Are bots a command line?</h4>

<p>See how there is a simile, but in fact, bots are the exact opposite from a command line.</p>

<p>Bot critics equate bots with CLIs and thus reach the conclusion that they are a step backward compared to GUIs.
The main argument is that bots do not have discoverability, that is, users will not know what they're capable
of since they don't have a menu with the available options. Whenever you're presented with a blank sheet, how
to start using it?</p>

<p>However, I believe this comparison is wrong. People don't have a post-it note
on their forehead stating their <em>available commands</em>, but we manage to work together, don't we?</p>

<p>We've been learning how to interact with people our whole lives; that's the point
of living in society. When we walk into a coffee shop, we don't need an instruction manual to know
how to ask for an espresso, or the menu, or request further assistance from the barista.</p>

<p>Bots can present buttons and images besides using text so, at the very least, they can emulate a traditional GUI.
This is not a killer feature but contributes to refute the <em>discoverability</em> criticism and provide
a transition period for users.</p>

<h4>Bots lack metaphors, and that is their biggest asset</h4>

<p>Bots will win because they speak natural language, even if it is only a dumbed down version.
Their goal, at least in the beginning, is to specialize in one use case: ordering a pizza, requesting weather information,
managing your agenda. 
After all, 90% of your interactions with your barista can be reduced to about ten sentences.</p>

<p>Being able to use natural language means there is no learning curve. And, for once in the history
of computing, users will be able to use a UI that lacks what all other UIs required to function: metaphors.</p>

<p>This is critical since metaphors are what regular people hate about computers.</p>

<p>Who cares if one needs to press seventy buttons to order a pizza with a bot instead of just three with an app. People
will use the product which is easier to use, not the one which saves them more keystrokes--not to mention
that you can send commands with your voice. Didn't we learn from GUIs?</p>

<h4>The death of the metaphor</h4>

<p>Every metaphor has been moving both hardware and software towards a more human way of working.</p>

<p>Files, folders, commands, the mouse, windows, disk drives, applications, all these have
been bright ideas that emerged at some point and then died when the next thing appeared. We even tried to 
<a href="https://en.wikipedia.org/wiki/Skeuomorph#Digital_skeuomorphs">style apps with leather and linen, buttons and switches</a>
to make them more understandable and relatable to the real world.</p>

<p>By definition, metaphors are a compromise. Both users and developers have a love-hate relationship with them, as they have been
necessary to operate computers, but they also impose a barrier between thought and action. </p>

<p>Thanks to metaphors, this <a href="https://en.wikipedia.org/wiki/Altair_8800">metallic thing which made funny noises and whose lights blinked continuously in 1975</a>
has now evolved to a very easy to use smartphone. But that smartphone still clearly is a computer, with buttons, windows, and text boxes.</p>

<p>Bots, if done correctly, may be the end of the computing metaphor.</p>

<h4>Metaphors have an expiration date</h4>

<p>This is not intrinsic of computers.</p>

<p>At some point in time, a watch was a metaphor for counting time. We designed a device with a hand pointing to numbers from 1 to 12
and we matched it to the sun cycle.
Advances in technology and culture have converted it in a fashion item and, while it still bears a metaphoric value, both four-year-olds
and ninety-year-olds can use it without much thinking.</p>

<p>It's like driving: once you master it, your brain operates the car in the background. Your eyes still look at the road, but unless there
is any unexpected issue, your conscious mind does not need to be driving.</p>

<p>I feel like the computing world, in general, is mature enough for this. Bots are a natural progression. They will not replace everything,
like bicycles do not replace trucks. For most people, however, <em>interacting with a computer as they do with a person is indeed the clincher</em></p>

<p>Ultimately, a tool is just a means to an end, and people
want to do things, not mess with tools. Some of us engineers do, but we're in the minority.</p>

<h4>Can we foresee the future?</h4>

<p>So, why bots and not another UI?</p>

<p>I haven't reached this conclusion myself, strong as some arguments may be. I just
follow the trend that thinkers have created. </p>

<p>The future is written in cyberpunk novels and philosophical AI movies, in music, in cinema. Not in blogs, not in
engineer forums, not in the mind of some visionary CEO.</p>

<p>People will use what people want, and the best demand creation machine is imagination, in the form of 
art and mass media.</p>

<p>What people will want is what artists have represented:
<em>futuristic VR and human-like --but not too human-looking-- software</em></p>

<p>And now for the final question. 
Chat bots and expert systems have been around <a href="https://en.wikipedia.org/wiki/ELIZA">since the 1960s</a>, 
so why is now the right time?</p>

<h4>All paths lead to Rome</h4>

<p>First and foremost, now is the right time because we <em>believe</em> it
is. Everything is pushing towards chat UIs: big players, money, startups, the media. </p>

<p>Marketing and news articles can make people like things, hate things, and love things.
People are told that they will be able to talk to their computers, and they've been baited
with Siris and Alexas. Those are not perfect, but hint of a better future.</p>

<p>Consumers imagine a plan for a better future and generate demand. And demand is the driver of innovation.
That's why in tech, self-fulfilled prophecies work, and predictions can be 
<a href="http://farm8.staticflickr.com/7010/6635615985_633d660428_o.jpg">incredibly accurate</a> even
<a href="http://www.wired.com/2014/05/victorian-postcards-predict-future/">over hundreds of years</a></p>

<p>At a technical level, both hardware and software are advanced enough for real-time audio and text
processing with natural language. APIs are everywhere, and some IA problems which were too hard ten years ago 
have been solved by either
<a href="http://www.aculab.com">commercial packages</a> or <a href="https://github.com/tesseract-ocr">free software libraries</a></p>

<p>Finally, the customer's computing environment is as close to bots as it can be.
Chat apps are <a href="http://www.fiercedeveloper.com/story/report-chat-apps-dominate-social-usage-and-time-spent/2014-11-27">the most used feature of a smartphone</a> because they're straightforward and personal.
People write or talk, and they get text or audio back. Not buttons, not forms, just a text box and a sentence.</p>

<p>My contrarian side feels a bit odd by tagging along the current big wave, 
but both rationally and by intuition I really do believe that now is the right moment. And I feel that I had to share
my reasons.</p>

<p>For what it's worth, I'm putting my money where my mouth is, developing bots <a href="http://paradoxa.io">at Paradoxa</a>.
Who knows what will happen anyway. Undeniably, nobody has a crystal ball. </p>

<p>But isn't trying to predict the future enjoyable? Just imagining it is half the fun.</p>

<p>Tags: <a href='tag_internet.html'>internet</a>, <a href='tag_startups.html'>startups</a>, <a href='tag_AI.html'>AI</a></p>

<!-- text end -->
<p id='twitter'><a href='http://twitter.com/intent/tweet?url=http://cfenollosa.com/blog/bots-lack-metaphors-and-that-is-their-biggest-asset.html&text=&lt;Type your comment here but please leave the URL so that other people can follow the comments&gt;&via=cfenollosa'>Comments? Tweet</a> 
<a href='https://twitter.com/search?q=http://cfenollosa.com/blog/bots-lack-metaphors-and-that-is-their-biggest-asset.html'><span id='count-15529'></span></a>&nbsp;</p>
<script type="text/javascript">$.ajax({type: "GET", url: "https://cdn.api.twitter.com/1/urls/count.json?url=http://cfenollosa.com/blog/bots-lack-metaphors-and-that-is-their-biggest-asset.html",
            dataType: "jsonp", success: function(data){ $("#count-15529").html("(" + data.count + ")"); }}); </script>
]]></description><link>http://cfenollosa.com/blog/bots-lack-metaphors-and-that-is-their-biggest-asset.html</link>
<guid>http://cfenollosa.com/blog/./bots-lack-metaphors-and-that-is-their-biggest-asset.html</guid>
<dc:creator>Carlos Fenollosa</dc:creator>
<pubDate>Tue, 17 May 2016 12:14:18 +0200</pubDate></item>
<item><title>
Why the centralization of the Internet is a bad idea
</title><description><![CDATA[

<p>You probably know that the Internet was born as a military project. That its goal was to have a computer network that survived a nuclear attack. Therefore, the pipes that make the Internet work are scattered through all the world. Every computer is connected to each other in a grid, more or less.</p>

<p>In theory, it’s easy: to go from computer A to C, go to B. If B is down, you can probably be routed through D and F and reach C nonetheless. To learn which is the best route, you ask a router. Apply recursively, and that’s the Internet!</p>

<p>However, the Internet is a technology, not an application. The applications we use are email, the Web, the Usenet, etc. Many popular services are nothing else than an API running on the Web. And most are centralized: to use Gmail you need to connect to the Gmail server. Makes sense, right?</p>

<p>In fact, that is not necessarily so; it has traditionally been the exact opposite, especially with email.</p>

<p>Email, along with web pages, it is the last bastion of decentralization on the Internet. You can install some software and send a message from your email server to another on the other side of the world without any meddling from third party servers — routers aside.</p>

<p>Most users don’t do that, though. Centralized systems are convenient. Managing a private server is complicated, and it forces you to have a computer running 24/7 at home, or rent one. Why should you handle this? Let the professionals do it, and end users can connect to centralized servers when they need to access a service.</p>

<p>There is a decentralized Facebook, called Diaspora, and a decentralized Twitter called Twister. BitTorrent is a decentralized file sharing system, Aether is a decentralized discussion forum, and there is even a decentralized currency called Bitcoin.</p>

<p>With them, you can have your data on your personal computer, or a machine you trust, and send specific pieces to your friends computers, without going through a central server. These services aren’t very popular at the moment, but due to increasing espionage, data selling, moderation abuse and others, their usage will probably increase, and pave the way for similar solutions soon.</p>

<p>Let’s get back to email for a minute because, unfortunately, its decentralization is jeopardized by a few powerful actors. There are strong reasons to trust big email providers, especially to avoid spam and fraud. Sadly, some of the measures used to filter potentially harmful emails also hurt small, honest servers, who see how their emails get rejected or delivered directly to the spam folder.</p>

<p>I’ve experimented with email servers since I was in college. Back in 2001, you could install an MTA and start sending emails without much trouble. However, for recent projects like Puput, installing and maintaining the email server has been nightmarish.</p>

<p>We are preparing the details for a future post, but to summarize, after installing postfix, no fewer than eight steps were required to get our emails successfully delivered into our users inboxes.</p>

<p>Both startups and the big players offer email delivery services, and I admit that had it not been for my obstinacy, we probably would’ve used some of them.</p>

<p>However, being as we are a bit old-school, used that your server could be a first-class node of the internet, that proved to us a serious ethical dilemma. Either you succumb to using one of the few “trusted email servers” or you essentially risk getting banned from delivering your own email. It is not yet blackmail, but it’s close.</p>

<p>I don’t want to be dishonest, there are genuine reasons for this. Trying to recentralize email may probably be just a measure to combat spam. <em>Probably</em>. Because when the big players have such large incentives to kill their competition and become The One Email Provider in the world, each barrier counts. It is not far-fetched to think that, at least, there are conflicts of interest among these big players.</p>

<p>Some sysadmins capitulate and end up using XYZ Apps for Business, surrendering a bit of the Internet’s decentralization to that company. Again, it makes sense, both technical and economical. Don’t reinvent the wheel. But every small decision we take contributes to create the world we want to live in.</p>

<p>Being a monopoly is tempting, and XYZ already has a history of embracing services like the Usenet, chat and RSS to kill them shortly afterward and force users to move to their proprietary solutions. In the 90s, XYZ was Microsoft. Nowadays, it is the formerly not evil company — ironic value of this left to the reader’s criterion.</p>

<p>With the de-facto death of Jabber, email and The Web are essentially the only popular services that you can still run from your private box and interact with the outside world. IM and social networks have been taken over by a dozen of centralized and isolated services; we can’t let email suffer the same fate.</p>

<p>Maybe the future of communications is just around the corner. When all devices are permanently connected to the Internet in a robust way, we will probably carry an <em>internet node</em> in our pocket. Meanwhile, we will keep using just an <em>internet access device</em> and reaching a central server to get our data, trusting that this machine doesn’t misuse it.</p>

<p><em>This post was originally posted on <a href="https://medium.com/@puput_io/why-the-centralization-of-the-internet-is-a-bad-idea-a79d698a37f3">Puput blog</a></em></p>

<p>Tags: <a href='tag_internet.html'>internet</a></p>



<!-- text end -->
<p id='twitter'><a href='http://twitter.com/intent/tweet?url=http://cfenollosa.com/blog/why-the-centralization-of-the-internet-is-a-bad-idea.html&text=&lt;Type your comment here but please leave the URL so that other people can follow the comments&gt;&via=cfenollosa'>Comments? Tweet</a> 
<a href='https://twitter.com/search?q=http://cfenollosa.com/blog/why-the-centralization-of-the-internet-is-a-bad-idea.html'><span id='count-20732'></span></a>&nbsp;</p>
<script type="text/javascript">$.ajax({type: "GET", url: "https://cdn.api.twitter.com/1/urls/count.json?url=http://cfenollosa.com/blog/why-the-centralization-of-the-internet-is-a-bad-idea.html",
            dataType: "jsonp", success: function(data){ $("#count-20732").html("(" + data.count + ")"); }}); </script>
]]></description><link>http://cfenollosa.com/blog/why-the-centralization-of-the-internet-is-a-bad-idea.html</link>
<guid>http://cfenollosa.com/blog/./why-the-centralization-of-the-internet-is-a-bad-idea.html</guid>
<dc:creator>Carlos Fenollosa</dc:creator>
<pubDate>Mon, 29 Feb 2016 15:23:00 +0100</pubDate></item>
<item><title>
A simple script to postpone your own email
</title><description><![CDATA[

<p>I somewhat use email as a task manager. Honestly, I believe we all do. We process emails in the inbox, then archive or delete them when we are done with them.</p>

<p>However, keeping track of emails that need a follow-up on a specific date can be difficult.</p>

<p>Around 2011 I wrote a script to perform that task. It is a very simple IMAP parser that searches for a folder with today's date and moves all its contents to a special folder named "Today".</p>

<p>Let me tell you my email workflow. I understand that not everybody works in the same way, but maybe you can get some ideas to improve your email handling.</p>

<p>My email folder structure looks like this. The interesting part is in bold.</p>

<pre>
Inbox
\_ Mailing lists
\_ Project folders
\_ ...
<strong>
\_ Deadlines
     \_ Today
     \_ Tomorrow
     \_ 2016-01-19
     \_ 2016-02-02
     ...
     \_ 2017-08-01
</strong>
</pre>

<p>I follow the GTD methodology, which essentially states that tasks should either be done on the spot, delegated, or deferred. Thus, my inbox is exclusively for new tasks. A couple of times a day I process incoming email and, like most of us, either delete it, reply to it, forward it or &mdash;this is the interesting part&mdash; move it to one of the "Deadlines" folders.</p>

<p>Instead of using the inbox as the "email task manager", I use a folder named "Today". I've tried both alternatives, and I find that it works best for me. Since it separates new tasks from tasks I've already processed, I can work my entire day on "Today" and totally forget about the Inbox, even if new email is arriving.</p>

<p>The "Tomorrow" folder is just a shortcut so that I don't need to create a new folder with tomorrow's date every day.</p>

<p>As you may have guessed, the script runs once a day in a crontab, at 6 AM, and moves all mail from "Tomorrow" and the folder with tomorrow's date to "Today". That's it. And that "simple trick", as fishy marketers like to say, saves me a lot of time and headaches every day.</p>

<p>There is currently a commercial alternative, <a href="http://www.boomeranggmail.com">Boomerang</a>, which you may find interesting if you aren't comfortable with programming. I haven't used it, so I can't comment on that. In any case, I usually prefer writing a small script rather than using a third-party service.</p>

<p>Update: <a href="https://github.com/kapravel/snoozegmail">this script</a> by Alex Kapravelos does something very similar, 
and it integrates with Google Apps Scripts.</p>

<p><a href="https://gist.github.com/cfenollosa/79c22e2ecbb2bdfee15b">Here it is, as a Gist</a>. 
The code is definitely not the best in the world, but it works. Feel free to use it, modify it (BSD license), give feedback and leave comments.</p>

<p>I hope that you can introduce some ideas from this methodology to your daily workflow. it can be as useful as it's been for me.</p>

<script src="https://gist.github.com/cfenollosa/79c22e2ecbb2bdfee15b.js"></script>

<p>Tags: <a href='tag_software.html'>software</a>, <a href='tag_tricks.html'>tricks</a>, <a href='tag_productivity.html'>productivity</a></p>





<!-- text end -->
<p id='twitter'><a href='http://twitter.com/intent/tweet?url=http://cfenollosa.com/blog/a-simple-script-to-postpone-your-own-email.html&text=&lt;Type your comment here but please leave the URL so that other people can follow the comments&gt;&via=cfenollosa'>Comments? Tweet</a> 
<a href='https://twitter.com/search?q=http://cfenollosa.com/blog/a-simple-script-to-postpone-your-own-email.html'><span id='count-15855'></span></a>&nbsp;</p>
<script type="text/javascript">$.ajax({type: "GET", url: "https://cdn.api.twitter.com/1/urls/count.json?url=http://cfenollosa.com/blog/a-simple-script-to-postpone-your-own-email.html",
            dataType: "jsonp", success: function(data){ $("#count-15855").html("(" + data.count + ")"); }}); </script>
]]></description><link>http://cfenollosa.com/blog/a-simple-script-to-postpone-your-own-email.html</link>
<guid>http://cfenollosa.com/blog/./a-simple-script-to-postpone-your-own-email.html</guid>
<dc:creator>Carlos Fenollosa</dc:creator>
<pubDate>Thu, 14 Jan 2016 17:36:00 +0100</pubDate></item>
<item><title>
What's up with disliking Liking?
</title><description><![CDATA[

<p>Twitter recently changed their faves for likes with much controversy and bashing Facebook's Likes is already a meme. What's up with disliking Liking?</p>

<p>Are we more narcissistic than ever? Maybe we are. Public image has always been important for two groups: public figures and teenagers. </p>

<p>I find myself lucky to have been a teenager in a world without social media. Otherwise, everyone could have been my adolescent cringe-inducing posts that were lost in private ICQ and MSN chats.</p>

<p>People need to feel important, and the new coolness ranking is social media Likes. Years ago, it was (paper) facebook notes and signatures. That's how the world works now, and we can only react to it, not change it.</p>

<p>Us adults tend to frown upon a teen posting a vaguely suggestive picture for their friends to Like but can't seem to enjoy a vacation unless we're sure all our coworkers are green with envy at our beach pictures. We can't start eating until everyone has uploaded a pic of its dish to Instagram as if waiting till mom finishes her prayer. </p>

<p>Technology is always ahead of society. It takes some time for people to adjust to new customs. We added "texting" to the list of things that are rude while dining at a table, then allowed some exceptions for important messages. We considered that leaving a meeting for a phone call is unprofessional, then accepted that people can have legitimate reasons.</p>

<p>Some will eat their dishes cold for some &hearts;s; others will unhealthily link their self-esteem to a particular threshold of Likes, and people will publicly mourn their dead in exchange for some sympathy.</p>

<p>In the end, liking somebody's content is a way of showing that you care about that person. Sympathy makes us human. Some will argue that private things should be kept hidden, but what's wrong if broadcasting their lives make people happy?</p>

<p>Everyone has their individual reasons for providing a Like or not; likewise, they are free to choose whether to publicize a personal event or not. Those who advertise all their illnesses on Facebook are no different than grandmas who go to the park and compete with other grandmas in the so-called ailment Olympics.</p>

<p>People need sympathy; Likes is just the channel that we use in the 2010s to provide it.</p>

<p>Tags: <a href='tag_internet.html'>internet</a>, <a href='tag_life.html'>life</a></p>





<!-- text end -->
<p id='twitter'><a href='http://twitter.com/intent/tweet?url=http://cfenollosa.com/blog/whats-up-with-disliking-liking.html&text=&lt;Type your comment here but please leave the URL so that other people can follow the comments&gt;&via=cfenollosa'>Comments? Tweet</a> 
<a href='https://twitter.com/search?q=http://cfenollosa.com/blog/whats-up-with-disliking-liking.html'><span id='count-16506'></span></a>&nbsp;</p>
<script type="text/javascript">$.ajax({type: "GET", url: "https://cdn.api.twitter.com/1/urls/count.json?url=http://cfenollosa.com/blog/whats-up-with-disliking-liking.html",
            dataType: "jsonp", success: function(data){ $("#count-16506").html("(" + data.count + ")"); }}); </script>
]]></description><link>http://cfenollosa.com/blog/whats-up-with-disliking-liking.html</link>
<guid>http://cfenollosa.com/blog/./whats-up-with-disliking-liking.html</guid>
<dc:creator>Carlos Fenollosa</dc:creator>
<pubDate>Sun, 10 Jan 2016 12:58:00 +0100</pubDate></item>
<item><title>
Puput, mail without internet
</title><description><![CDATA[

<p>Here's my new project: <a href="http://puput.io">Puput</a>, a service which lets you
listen to your email when you have no internet.</p>

<p>I honestly think it's pretty cool, the project has a strong R+D component for which we filed a patent,
and it has lots of potential to <a href="http://puput.io/slack.html">integrate into IMs like Slack</a>
and close the communication gap for people who are offline.</p>

<p>It's free, so please be my guest and give it a try! It's surprisingly awesome to be able to listen
to your email when you're abroad without an internet connection.</p>

<p>Even though we have been absorbing a lot of startups-related material these last months,
nothing will prepare you for a real product launch. Everybody says it, and I agree: </p>

<ul>
<li>The last 20% of the work consumes us 80% of the time. That is, UI, UX, the website,
and the marketing strategy</li>
<li>Selling is hard.</li>
<li>Selling is even harder when you first invent a new technology and then try to find 
use cases for it. Yes, the <em>lean startup</em> recommends doing the opposite, it is a common
first timer mistake :(</li>
<li>I'll say it again, do product/market fit first, then start coding.</li>
<li>Raising money is nearly impossible in the Spanish startup scene. Obviously we're nobodies, but
I've also talked to many other founders, with great products, thousands of clients and 
two-digit monthly growth, who find it incredibly frustrating to raise even 200k&euro;</li>
<li>Launch day is scary so you find excuses not to launch. Adding more features is one of them. Establish
hard deadlines and try to respect them as much as possible.</li>
<li>It turns out it isn't that scary anyways, in fact, getting users and attention is difficult at first.
<em>Dying from success</em> is unrealistically represented in sites like HN, it doesn't apply to 99% of the startups.</li>
</ul>

<p>Anyway, launching a product is hard, teaches you many things about the world, and makes you
respect people who have done it successfully. </p>

<p>Cheers to all first time founders.</p>

<p>Tags: <a href='tag_internet.html'>internet</a>, <a href='tag_software.html'>software</a>, <a href='tag_startups.html'>startups</a>, <a href='tag_projects.html'>projects</a></p>





<!-- text end -->
<p id='twitter'><a href='http://twitter.com/intent/tweet?url=http://cfenollosa.com/blog/puput-mail-without-internet.html&text=&lt;Type your comment here but please leave the URL so that other people can follow the comments&gt;&via=cfenollosa'>Comments? Tweet</a> 
<a href='https://twitter.com/search?q=http://cfenollosa.com/blog/puput-mail-without-internet.html'><span id='count-30786'></span></a>&nbsp;</p>
<script type="text/javascript">$.ajax({type: "GET", url: "https://cdn.api.twitter.com/1/urls/count.json?url=http://cfenollosa.com/blog/puput-mail-without-internet.html",
            dataType: "jsonp", success: function(data){ $("#count-30786").html("(" + data.count + ")"); }}); </script>
]]></description><link>http://cfenollosa.com/blog/puput-mail-without-internet.html</link>
<guid>http://cfenollosa.com/blog/./puput-mail-without-internet.html</guid>
<dc:creator>Carlos Fenollosa</dc:creator>
<pubDate>Mon, 21 Dec 2015 17:25:00 +0100</pubDate></item>
<item><title>
"Think of the terrorists" is the new "Think of the children"
</title><description><![CDATA[

<blockquote>
  <p>If I am prime minister, I will make sure that it is a comprehensive piece of legislation that makes sure we do not allow terrorists safe space to communicate with each other. That is the key principle: do we allow safe spaces for them to talk to each other? I say no, we don't, and we should legislate accordingly.</p>

<p><em>&mdash;David Cameron</em></p>
</blockquote>

<p>What infuriates me the most is that is such a blind, selfish, first world argument. It implies freedom of speech is granted, ubiquitous, and irreversible, so those who want extra protection must be criminals. Mr. Cameron's statement also assumes that there is no middle ground, and all technologies that can be misused by some party should be illegal. You know, the Hitler-croquettes theorem: since Hitler liked croquettes, croquettes must be bad.</p>

<p>In some countries, the Government can kill you for your political views. Your neighbors can also kill you for what you are&mdash;gay, for example. Ill-named "activists" can kill you for private beliefs that don't affect other people, like your stance on abortion. Mafias can kill you for badmouthing. And these all happen in first world countries, can you imagine the rest of the world?</p>

<p>Requesting those people to abandon the tool that is currently saving their lives in exchange for <a href="https://www.reddit.com/r/india/comments/3csl2y/wikileaks_releases_over_a_million_emails_from/csyjuw6">the vague promise of finding terrorists</a> is a false dichotomy. I can understand uneducated people considering this topic as black and white. But a Prime Minister? That's a supreme level of blindness. </p>

<p>Mr. Cameron and others surely understand how the world works. They know that hackings, theft, revolutions, and coups d'etat exist, and those who once were righteous, legal and legitimate may be prosecuted. Something being <em>legal</em> or <em>punishable</em> can quickly change, it is not written in stone, and definitely not universal.</p>

<p>Imagine a Christian in 2011 Syria. They lead an ordinary life, have a job, a Facebook, they send funny memes to their friends, they communicate online. Being a Christian something we can agree is a legitimate and harmless belief and, according to 2011 Syria's laws, legal.</p>

<p>Now meet ISIS. In just a year they have conquered a large portion of the territory and changed some laws considerably. Forbidding Christians in Syria to use encryption is, with Mr. Cameron's words, <em>not allowing people a safe space to communicate with each other</em>, and exposing them to ISIS. You see, in some cases, <em>banning encryption helps terrorists</em>.</p>

<p>That is not a paradox. Encryption is a tool, like a knife, a chainsaw or a Bic pen. Banning a tool has consequences, and arguing at a fallacy level with something as serious as the lives of people is deeply insulting.</p>

<p>We need encryption, period. Personal communications must be private, period. We can discuss the transparency/secrecy balance for governments, but that is a topic for another day.</p>

<p>Governments must find some other way of fighting crime than just exposing everybody naked to make it easier to pick the bad apples.</p>

<p>Encryption is saving lives of gays, Muslims, activists, individuals who are threatened. It is allowing Mr. Cameron to send private texts to their wife without The Sun intercepting them. It is what avoids ISIS to spy on the UK Ministry of Defence intelligence. Does he really not realize that? Is he not that bright? Is he ill-advised? Is he just a hypocrite?</p>

<p>Encryption is avoiding that in a massive wirelessly connected world anybody can listen to what everybody else is saying in any part of the planet. <em>Do we allow safe spaces for people to talk to each other? I say yes, we do, and we should legislate accordingly</em></p>

<blockquote>
  <p>When it comes to privacy and accountability, people always demand the former for themselves and the latter for everyone else</p>

<p><em>&mdash;David Brin</em></p>
</blockquote>

<p>Tags: <a href='tag_law.html'>law</a>, <a href='tag_internet.html'>internet</a></p>









<!-- text end -->
<p id='twitter'><a href='http://twitter.com/intent/tweet?url=http://cfenollosa.com/blog/think-of-the-terrorists-is-the-new-think-of-the-children.html&text=&lt;Type your comment here but please leave the URL so that other people can follow the comments&gt;&via=cfenollosa'>Comments? Tweet</a> 
<a href='https://twitter.com/search?q=http://cfenollosa.com/blog/think-of-the-terrorists-is-the-new-think-of-the-children.html'><span id='count-9553'></span></a>&nbsp;</p>
<script type="text/javascript">$.ajax({type: "GET", url: "https://cdn.api.twitter.com/1/urls/count.json?url=http://cfenollosa.com/blog/think-of-the-terrorists-is-the-new-think-of-the-children.html",
            dataType: "jsonp", success: function(data){ $("#count-9553").html("(" + data.count + ")"); }}); </script>
]]></description><link>http://cfenollosa.com/blog/think-of-the-terrorists-is-the-new-think-of-the-children.html</link>
<guid>http://cfenollosa.com/blog/./think-of-the-terrorists-is-the-new-think-of-the-children.html</guid>
<dc:creator>Carlos Fenollosa</dc:creator>
<pubDate>Sat, 11 Jul 2015 13:23:00 +0200</pubDate></item>
<item><title>
OpenBSD from a veteran Linux user perspective
</title><description><![CDATA[

<p>For the first time I installed a BSD box on a machine I control. The experience has been eye-opening, especially
since I consider myself an "old-school" Linux admin, and I've felt out of place with the latest changes on the
system administration. </p>

<p>Linux is now easier to use than ever, 
but administration has become more difficult. There are many components, most of which
are interconnected in modern ways. I'm not against progress, but I needed a bit of recycling. So instead of
adapting myself to the new tools, I thought, why not look for modern tools which behave like old ones?</p>

<p>This article discusses some of the main differences between OpenBSD and Linux, from a Linux admin perspective.</p>

<p>There are some texts on the net discussing the philosophical differences between BSDs and Linux, but
not many of them are really hands-on. <a href="https://www.over-yonder.net/~fullermd/rants/bsd4linux/01">This one</a> is the best,
and I recommend you to read it along with this one.</p>

<p>Since I am new to OpenBSD, I may get some things wrong. Please email me any corrections.
However, my goal is to point out my first impressions, so if there are any Linux users reading and thinking about making the jump, 
they can know what to expect.</p>

<p><em>Final update: I've received a huge amount of feedback from this article, overwhelmingly
positive, and very welcoming from the OpenBSD community.</em></p>

<p><em>This text's goal is to discuss an OpenBSD newbie's first impressions and, as such, I'm
realizing that some parts aren't totally accurate. However, I want to keep that perspective,
so in the future I'll prepare a more technical guide on how to migrate to OpenBSD for Linux users.
Thanks everyone!</em></p>

<h4>The "RAMDAC" running joke</h4>

<p>First, some background about my Linux experience.</p>

<p>My first computer was a 386 with DOS and Windows 3.1. I had played with Spectrums, Commodores, and
IBM PCs (8086). I followed the traditional Windows path: 3.1 -> 95 -> 98 -> ME -> 98 -> 2000. But
I always liked computers, and the most visible part of them, besides the hardware, is the OS.</p>

<p>I tried to install my first Linux distro on 1999. It was a Red Hat Linux 5.2, if I remember correctly, 
and I got the CD from a magazine because I was still running a dial-up. I was 15 and I thought I knew
computers, after all, I had assembled my own, an AMD K6-2 box, from parts.</p>

<p>Red Hat proved me wrong.</p>

<ul>
<li><em>Which is your chipset?</em></li>
<li>Man, I don't know</li>
<li><em>Which is the model of your RAMDAC?</em></li>
<li>What is a RAMDAC?</li>
<li><em>I need <a href="http://archive.download.redhat.com/pub/redhat/linux/7.1/kr/doc/RH-DOCS/rhl-ig-itanium-en-7.1/figs/textmode/monitor.gif">your monitor modelines</a>. Don't get them wrong or you will physically damage your CRT</em></li>
<li>Dude, I'm 15, I can't afford to break anything!</li>
</ul>

<p>In the end I didn't break my monitor, but
got a black screen which said <code>login:</code>, and didn't know what to do, so I booted back
into Windows and played a bit of Warcraft 2.</p>

<p>In that age we only had one computer, so if you were installing something and needed
help, you had to stop, reboot into Windows, dial up the modem, search the Usenet or forums, write down
the solution on a piece of paper&mdash;no ubiquitous printers&mdash;, hope you got the commands right, reboot, start the installation over,
reach the point where you previously were, and apply that solution. Not practical at all. </p>

<p>The best
help we had were books, and those were expensive and difficult to find on a small town bookstore.
For those of us not fortunate enough to buy/find books, we had hobbyist magazines. In Spain there were a few
imported and poorly translated magazines which were expensive, but carried some CDs, the only practical
way to get distros.</p>

<p>The first Linux I really was able to use was Mandrake 6.0. It had a graphical installer&mdash;not that having graphics
made any real difference on the final result&mdash; but it auto detected my hardware correctly and booted into X. Yeah! 
<a href="http://www.betaarchive.com/imageupload/2014-12/1419415455.or.26035.png">Old Linux software</a>! 
A game called Nethack which had nothing to do with hacking! <code>sysconfig</code>!</p>

<p>Unfortunately, I couldn't connect to the internet because of my Winmodem, so after a few days of tinkering, Mandrake 
was wiped too.</p>

<p>Months later, I got myself a BeOS CD. It was like Linux, which for me, then, meant it was not Windows. The setup ran totally
effortless and it even detected my Winmodem. The internet ran faster than on Windows. It had a great
internet browser, mail and newsgroups clients. Oh, boy! I used BeOS for a long time almost exclusively
and only booted Windows to play some games.</p>

<p>A couple years later I started Computer Engineering on college, so I wiped out everything and installed Linux.
I got a new machine and a real network connection.</p>

<p>I've run lots of Debians, Red Hats, Mandrakes, Gentoos and Slackwares. We used Solaris and even some VAXes.
I ran some servers for student organizations, and finally settled on Debian as "the best" distro: stable,
easy to use, no need to compile on our 486, nice hardware detection and with a big community.</p>

<p>Finally, I moved to Ubuntu if only because its LTS releases. Around 2006 I got into Macs, which at first seemed like a nicer Linux, and
now I appreciate the hardware+software combo for which I know I won't have to fight with its drivers. </p>

<p>In summary, I've seen a lot of UNIX, even more Linux, and administered a good chunk of them. My servers have
always run some sort of Debian.</p>

<p>You could say that as I grew older I also grew tired of fighting with RAMDACs, modelines and Winmodems.
Each age brought new "RAMDACs": CD recording, wireless card support, laptop hibernation, webcams, divx playing,
DVD playing, NTFS support...</p>

<p>Linux always worked in the server but had some quirks in the desktop which made it somewhat unattractive for daily use,
even when I run it exclusively on my laptop.</p>

<p>Nowadays, Macs offer a UNIX with some peace of mind, and the current status of Linux is good enough. Some of the friends I
evangelized long ago&mdash;I quit doing that&mdash;still use Ubuntu and are happy with it. Linux may never triumph
on the desktop (or laptop), but it's good enough for most.</p>

<h4>Upgrading a G4 Mac Mini</h4>

<p>Now jump to 2015. My home server, a G4 Mac Mini, was already two Debians behind. Some packages weren't ported to
<em>powerpc</em>. I needed to perform a clean install and upgrade the whole system either way. But this time I didn't want to use a Linux
installation which wants me to reboot every 5 days because of some critical patch. I'm looking at you, Ubuntu.</p>

<p>As you can imagine my operating system fascination didn't fade out, only my time. I had been closely following the BSDs and
using <a href="http://cfenollosa.com/blog/the-sdf-public-access-unix-system----est-1987.html">a NetBSD shell account</a>, installed Plan 9
on a virtual machine,
and even wrote <a href="https://github.com/cfenollosa/os-tutorial">a toy OS project</a>. </p>

<p>I'm not afraid of compiling stuff&mdash;I do it for a living&mdash; and may even be open 
to modifying some code if needed. Why not try something new?</p>

<p>Since I had the weird <em>powerpc</em> requirement, I ruled out most operating systems. Finally I decided to play relatively
safe and go for a BSD. FreeBSD is the most popular, has
more online HOWTOs, and probably more features (ZFS, Jails), though I probably would not be using them. OpenBSD
is more hackable, seems to have better documentation, and some cool people I know use it. I didn't want to quit using a pot
to start using a kettle, so I downloaded OpenBSD's <code>install57.iso</code></p>

<p>It was impossible to boot the Mini with a USB stick; I'm unsure if it's the firmware's fault
or the fact that I was <code>dd</code>'ing the .iso file into the USB instead of the .fs one which doesn't seem to be available
for macppc.</p>

<p>I found some blank DVDs on a closet, borrowed a computer 
with a DVD drive&mdash;another medium I hadn't touched in years&mdash;, and burned the ISO image. 
The fact that I recorded the first disk with the ISO file on the root folder
instead of properly burning the contents into the DVD warned me that this was going to be hard, but fun... </p>

<p>Surprisingly, the installation was straightforward, it detected the 10-yr-old hardware, and by following the instructions
I managed to partition the disks and install the boot loader. The box was up and running.</p>

<p>Well, that wasn't so hard, was it? Now, to restore my old installation.</p>

<p>Hm, first of all, 
<code>bash</code> needs to be installed from packages and goes into <code>/usr/local/bin</code>, so I had to
modify a lot of scripts which pointed to <code>#!/usr/bin/env bash</code>. The <code>ps</code> and <code>tar</code> commands have slightly different
switches which broke other scripts. 
The base services are different; OpenBSD includes its own HTTP, SMTP and NTP servers. Configuration files
are in different places. Here goes my week...</p>

<h4>GNU is really not UNIX</h4>

<p>A quick note on the GNU/Linux naming discussion, since GNU is entering the equation now.
I use the term "Linux" for simplicity. I know that's the kernel name. It also happens to be
the popular name, even if not totally correct&mdash;according to some.</p>

<p>Here is some food for thought; why does the FSF deserve more credit on the name than, say, the Apache Foundation, 
or the FreeDesktop project, or BSD, for that matter? Why don't we include every key component on the name 
and call it GNU/FreeDesktop/Apache/OSI/BSD/.../Linux? Including only GNU would be unfair
to other big contributors, wouldn't it? So let's please stop this fight.</p>

<p>That being said, the GNU tools and design philosophy make a noticeable difference in administration and userspace, and one can only appreciate
it when switching to a different environment.</p>

<p>I don't want to overstate it, though. Thanks to POSIX, a Linux admin
can run BSD with little extra effort, since most of the things are similar. There are, in fact, more similarities than
differences. If FreeBSD and OpenBSD are brothers, then Linux is a close cousin.</p>

<p><code>ls</code> is always <code>ls</code>. <code>mkdir</code> is <code>mkdir</code>.
But when you're being used to <code>/dev/hda</code>, <code>free -m</code> and <code>cat /proc/cpuinfo</code> you realize that having a different
kernel is naturally going to change some of the administration tools.</p>

<p>Some say that the GNU tools <a href="http://suckless.org/sucks">are bloated</a> and that the BSD toolchain is more "pure UNIX".
The reality is that it depends on the specific GNU tool, I've personally found that GNU tools are more complex because
they're more powerful, though they are less UNIX-like <em>(do one thing only and do it well)</em> and more like complete
solutions. That's fine; different, but fine. After all, GNU is not Unix!</p>

<p>In recent years, the Linux environment has grown in the GNU toolchain fashion, not the UNIX fashion. One may even say
it has grown in the <em>Windows fashion</em>: be practical, be accommodating to all, be fast, be modern.</p>

<p>There have always been debates
about "bloated and complex code". More recently, systemd. Previously, Apache, sysconfig, iptables/iptools.... 
The list goes on and on. Wheel out comp.os.linux and look at the flame wars.</p>

<p>No software fits all nor should be shamed for its design decisions. In the end, with
a few critical exceptions like <a href="https://en.wikipedia.org/wiki/Heartbleed">OpenSSL and the Heartbleed bug</a>, it is just
a matter of taste: does the admin prefer simple, pluggable services, or bit monolithic suites? Compatibility or modernness?
Familiarity or <a href="http://www.jwz.org/doc/cadt.html">shiny new things</a>? Standards or <a href="https://en.wikipedia.org/wiki/Not_invented_here">NIH</a>?</p>

<p>I had been riding the Linux wave for years, until I recently realized that my admin skills needed a total
recycling. In a few years we've gone from <code>/etc/init.d/sshd restart</code> to <code>service sshd restart</code> to <code>systemctl start sshd</code>.
That's a bit fast in my opinion, but I understand it's the price of progress, aimed to make computers boot
faster and theoretically easier to administer for newcomers. Old admins, on the other hand, have a harder time adapting.</p>

<p>Having to choose between recycling into an always changing Linux or a more stable UNIX environment, I chose OpenBSD.
Given my history of trying all possible OSs, 
Let me state again that I'm not against the recent Linux direction. I just wanted to go out and see if there is a different way
to do things.</p>

<h4>Differences between OpenBSD and Linux</h4>

<p>Maybe you're reading this article for its practical value and not for my ramblings, sorry.
I thought I had to provide some context. I'm used to googling, I'm used to RTFMing, I'm used
to reading source code to learn what software does. This context is important to judge if
you would notice the same differences as I did.</p>

<p>Here's a list of things that surprised me the most after completing an OpenBSD install, adapting
my old setup to the new environment and running it for a few days.</p>

<p><strong>Simplicity</strong></p>

<p>First of all, everything is much simpler, like the Linux old days. Not necessarily easier, but
simpler. More minimalistic. I found this plays well with my mind. OpenBSD follows <a href="http://www.catb.org/esr/writings/taoup/html/ch01s06.html">the UNIX 
philosophy</a> 
more closely: lots of small components that do one thing and 
talk between them by passing text.</p>

<p>Because of that, some base components are not as feature-rich, on purpose. Since 99% of the servers don't need
the flexibility of Apache, OpenBSD's httpd will work fine, be more secure, and probably faster.
For those who need the big boys, just install Apache from the packages. </p>

<p>Having a developer-chosen default option for many servers is a time saver. The admin knows it will be
well supported and documented, and tightly integrated with other components. The alternative, the
Linux way, is to just use what everybody else uses (Apache), or choose one of the multiple options, always
wondering if it's the right one&mdash;nginx? lighttpd? thttpd? You know what... <em>nobody got ever fired
for choosing Apache</em></p>

<p><strong>Design decisions</strong></p>

<p>Picking up on that thought,
the system is very opinionated. When the community decides that some module sucks, they develop
a new one from scratch. OpenBSD has its own NTPd, SMTPd and, more recently, HTTPd. They work
great.</p>

<p>Likewise, the standard shell is <code>pdksh</code>. The <a href="http://www.openbsd.org/faq/faq9.html">OpenBSD FAQ</a> states that 
<em>"Users familiar with bash are encouraged to try ksh(1) before loading bash on their system -- it does what most people desire of bash."</em>,
which is a bit too bold. ksh does not support history substitution (<code>sudo !!:1</code>) which I use a lot, though I agree
that for many users it will be enough. Many people hate bash for a reason, I am not one of them.
Having a super powerful shell has saved me from writing perl scripts for system administration.
Bash can always be installed from packages, anyway.</p>

<p>This is a big difference from Linux, which is more like a "consensus" operating system. Developers have
to keep compatibility and whenever there is a controversial design decision like systemd, dozens of
projects <a href="https://xkcd.com/927/">decide to fork</a>. Not good.</p>

<p>Strong opinions, on the other hand also lead to less support for some, like ext4, ZFS or Linux binary compatibility.
For example, ext4 is officially supported read-only but in my case it didn't read some folders properly.
FreeBSD plays better on that regard, though they also have more developer manpower. This leads to some use cases, 
like an OpenBSD desktop, being possible but not the best choice for this OS.</p>

<p>Finally, other decisions make little sense. According to disklabel(8), the /usr partition takes
about 2G of disk space, not including /usr/src or /usr/obj. This means that there is little
space to hold what is essentially the whole system plus ports. I had trouble compiling large ports
since /usr ran out of disk space. If a large number of users will be compiling some ports, why not
set a larger /usr by default?</p>

<p><strong>Documentation</strong></p>

<p>The man pages are excellent, a delight. Unlike Linux, they
are not just a list of switches for the software, but a comprehensive guide to the tool, with
lots of examples. They are much, much better&mdash;thankfully, because unlike Linux, again,
there are not tons of help on public forums.</p>

<p>OpenBSD's man pages are so nice that RTFMing somebody on the internet is not condescending but selfless.</p>

<p>Granted, I wouldn't make a UNIX novice run OpenBSD from man pages, but for an experienced admin, they contain
exactly the information they need.</p>

<p><strong>Small differences in common tools</strong></p>

<p>Using the BSD toolchain instead the GNU one means there are small differences between tools. 
For example, some <code>ps</code> switches are missing, like the useful <code>-f</code>. The <code>tar</code> options for reading from stdin
are also slightly different. When <code>ls</code> is run by root, it automatically appends all hidden files.</p>

<p><code>df</code> has <code>-h</code> (human) and <code>-k</code> (kilobytes), but no <code>-m</code> for megabytes.</p>

<p>If you've used MacOS you probably know a few of these.</p>

<p><strong>Packages</strong></p>

<p>OpenBSD has packages, like Linux. Unlike it, packages are only available for 3rd party software, not the base
system. </p>

<p>OpenBSD's base system is more or less what gets installed from the CDs: kernel, shell, coreutils,
a small part of X and essential servers (http, ntp, smtp, etc.) Everything else must be installed from packages.</p>

<p>The documentation recommends using packages, since it is not worth it to compile from ports&mdash;the package
sources. However, packages don't get security updates. The only way to patch bugs is to compile the ports.</p>

<p>Fortunately, there is a simple way to use the best of both worlds: add <code>FETCH_PACKAGES=yes</code> to <code>/etc/mk.conf</code>
and install software from ports. The system will automatically fetch the package and save the compilation 
time if there is a current binary available.</p>

<p>Another interesting tool is <code>/usr/ports/infrastructure/bin/out-of-date</code>, which checks which ports need
an update, so you can go to <code>/usr/ports/&lt;portname&gt;</code> and <code>make update</code>. This command plays well with previously
installed packages, so you don't have to worry deleting them first.</p>

<p>In summary, after you install the release, if you're interested in getting security updates until next
release, the officially recommended path is to <a href="http://www.openbsd.org/stable.html">follow -stable</a>, use <code>FETCH_PACKAGES</code> and work from ports.
This is not very clear in the documentation but the folks at <a href="irc://freenode.net/openbsd">#openbsd</a>
helped me figure it out.</p>

<p>As a colophon, if you're using x86 or amd64, <a href="https://stable.mtier.org">m:tier</a> provides binary updates
for the base system and packages, much like Linux does. Otherwise, if 
there is any bug in the base system you'll need to
recompile that part yourself. The amount of compiling needed will be determined
by the patched component and any related software, so just read the
instructions on the patch.</p>

<p><strong>Configuration files</strong></p>

<p>The base system config files are properly centralized in <code>/etc</code>, but
not the ports. The porting quality is excellent, better than any Linux distro. Every port is adapted
to the OpenBSD system and made sure it behaves correctly. However, some maintainers decide that all
the port files need to be contained in some folder, like <em>transmission-daemon</em>, which stores its
config into <code>/var/transmission/.config/transmission-daemon/settings.json</code>. It's a bit crazy to store
a system-wide daemon config file into <code>/var</code> which, according to <code>man hier</code>, contains
<em>Multi-purpose log, temporary, transient, and spool files</em>. </p>

<p>Apparently some daemons are chrooted by default, and there is a global "catch-all" README folder
on <code>/usr/local/share/doc/pkg-readmes</code> which contains specific info about packages. transmission-daemon
had no related info, so maybe I'll contact the maintainer.</p>

<p><strong>Chroot</strong></p>

<p>Speaking of roots, nearly all daemons in the base system are chrooted and
privstep by default. The base system has a lot of hardening by default,
which is one of the main reasons why OpenBSD has almost no remote holes
on the default installation.</p>

<p>Since chrooting software in Linux can be cumbersome, it's very convenient
to get it done for you, so thanks!</p>

<p><strong>Experienced community</strong></p>

<p>I feel like the learning curve
is a feature, not a bug, intended to keep newcomers away. OpenBSD is unapologetically elitist.
Honestly, I don't mind that. I've been administering systems for more than a decade
and not all environments are for everybody.</p>

<p>OpenBSD <em>can afford</em> to be elitist because it is a small system, with a clear direction, the documentation
is crystal clear, and it doesn't make vague promises.</p>

<h4>make build</h4>

<p>As you can see there is a big <em>con</em> to using OpenBSD coming from a Linux world, 
the process for patching security issues. On Linux I was used to
run a single command and let any part of the system (base or 3rd party) update itself. With
OpenBSD, it takes a lot more effort and time, especially in my old machine.</p>

<p>This process leaves the admin only one realistic option: follow the -stable branch, which is basically the same
code as the CD release with small patches, and recompile stuff regularly. Otherwise, the installed
system will be exposed to potential security holes until the next release.</p>

<p>I feel that this needs to be more prominent in the OpenBSD docs, especially on the <a href="http://www.openbsd.org/faq/faq9.html">Migrating to OpenBSD</a>
section: <em>if you want an updated and stable
system you'll need to recompile stuff constantly, there is no equivalent to <code>apt-get upgrade</code></em>.</p>

<p>To get a secure production system with OpenBSD, the officially recommended path is to:</p>

<ol>
<li>Install the CD release</li>
<li>Download the source code</li>
<li>Recompile the kernel (recommended by "following -stable")</li>
<li>Recompile userland</li>
<li>Download ports tree</li>
<li>Add <code>FETCH_PACKAGES=yes</code> to <code>/etc/mk.conf</code> to let ports fetch packages, if available,
and install software using the ports syntax.</li>
<li>Recompile when there is a security issue which affects
your setup, though you may skip some compiling if using m:tier.</li>
</ol>

<p>Of course, this is a feature, not a bug, but it's the biggest admin change from old Linux users.
That's a lot of effort compared to <code>apt-get update &amp;&amp; apt-get upgrade</code>. Honestly, had I known it,
I would've more strongly considered keeping my Debian installation. I read all the online documentation before
installing OpenBSD, and I felt like this point wasn't really clear.</p>

<p>Since you can safaly use -stable ports/packages with a -release base system, 
steps 3-4 can be avoided or shortened if you don't want to update your base to -stable. That's
what I would recommend to former Linux users, but take this newbie's advice with a grain of salt.</p>

<p>In any case, for low-performing machines like mine, maybe the "recommended" path to follow -stable
and rebuild the source for every errata is not the best one. For small fixes it may be better
to just apply the patch and follow its instructions. Apparently in faster machines it's just
more convenient to recompile the base system since it takes just a few minutes. 
Had I been using x86 or amd64, I'd have totally gone for m:tier, so you can dismiss this section.</p>

<p>To be totally fair, it's rare for OpenBSD to have remote holes on the CD release, so one could
be relatively safe by only upgrading from release to release. But the truth is that there is
no simple way to binary patch for critical updates.</p>

<p>With that it mind, to summarize, there are the following options:</p>

<ul>
<li>Use a -release base and -stable ports (with <code>FETCH_PACKAGES=YES</code>), 
cherry-picking patches from base and updating ports by <code>make update</code>.
This may be the recommended path for low-performing machines</li>
<li>Use a -stable base, too. You can then update the whole system with a 
handful of commands and won't need to follow patch instructions</li>
<li>Use -release and update from m:tier</li>
<li>Keep using -release until a next -release comes, unless there is
an unlikely remote hole that forces you to recompile the base. This
may be the best option for newbies if the only person using the box 
is the admin, so there is no way to suffer local attacks.</li>
</ul>

<h4>Conclusion</h4>

<p>From a user perspective all of this is transparent; OpenBSD has a UNIX terminal or Xwindows session
and everything works as expected. But a Linux admin will need to adapt to these new tools and
allocate some more time for administration.</p>

<p>OpenBSD has pros and cons. Personally, my main pros are the excellent documentation, its minimalism and
the choice of default daemons. The only con is the need to recompile to patch errata.
If I had just one wish for OpenBSD, it would be a more straightforward updating system for 
security errata.</p>

<p>Now, the dreaded question. <em>Is it worth it?</em></p>

<p>Honestly, I wasted too much time. Some of it was to be expected, since I needed to learn a different
environment. Had I been 10 years younger, this wouldn't have been a problem, but
I want a hassle-free environment. The fact that I needed to compile things on an old machine
probably didn't help. Keep that in mind when considering a BSD for an old, weird architecture.</p>

<p>After the initial investment, I want to see if maintenance is easier and release upgrades
are smoother than with Debian. Manually upgrading things is a pain in the neck, but all other
factors lead me to think that OpenBSD is a great server OS.</p>

<p>Maybe I was expecting something else from the docs I read? It 
is probably my fault, though. Anyway, I want to contribute to the available documentation by
writing this document so that other Linux admins can make a more informed decision.</p>

<p>On the other hand, my geeky side is content. OpenBSD rocks. It is a different&mdash;a real&mdash;UNIX
and I've really come to appreciate simple code and software. As an admin, having minimalistic, default
servers is a blessing.</p>

<p>Again, should you try OpenBSD? The answer is yes, though be careful if you're either in a rush or have 
specific software requirements. The first days are a bit hard,
and recompiling on a slow machine takes time.</p>

<p>If you like UNIX, it will open your eyes
to the fact that there is more than one way to do things, and that system administration
can still be simple while modern.</p>

<p><em>Revised with contributions from <a href="http://www.bsdnow.tv">TJ</a> and <a href="https://mike-burns.com">Mike</a>. Thanks!</em></p>

<p>Tags: <a href='tag_software.html'>software</a>, <a href='tag_unix.html'>unix</a></p>








<!-- text end -->
<p id='twitter'><a href='http://twitter.com/intent/tweet?url=http://cfenollosa.com/blog/openbsd-from-a-veteran-linux-user-perspective.html&text=&lt;Type your comment here but please leave the URL so that other people can follow the comments&gt;&via=cfenollosa'>Comments? Tweet</a> 
<a href='https://twitter.com/search?q=http://cfenollosa.com/blog/openbsd-from-a-veteran-linux-user-perspective.html'><span id='count-8960'></span></a>&nbsp;</p>
<script type="text/javascript">$.ajax({type: "GET", url: "https://cdn.api.twitter.com/1/urls/count.json?url=http://cfenollosa.com/blog/openbsd-from-a-veteran-linux-user-perspective.html",
            dataType: "jsonp", success: function(data){ $("#count-8960").html("(" + data.count + ")"); }}); </script>
]]></description><link>http://cfenollosa.com/blog/openbsd-from-a-veteran-linux-user-perspective.html</link>
<guid>http://cfenollosa.com/blog/./openbsd-from-a-veteran-linux-user-perspective.html</guid>
<dc:creator>Carlos Fenollosa</dc:creator>
<pubDate>Fri, 26 Jun 2015 19:19:00 +0200</pubDate></item>
</channel></rss>
